import { Requester, Result } from "./base"
export * from "./base"
/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "AppId".
 */
export type AppId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "AppMediaObjectId".
 */
export type AppMediaObjectId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "AppTaskId".
 */
export type AppTaskId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ChannelMask".
 */
export type ChannelMask =
  | {
      mono: number
    }
  | {
      stereo: number
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ClientId".
 */
export type ClientId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SocketId".
 */
export type SocketId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "PlayId".
 */
export type PlayId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "FixedInstanceId".
 */
export type FixedInstanceId = string
/**
 * A pad that can receive connections on a node inside a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "OutputPadId".
 */
export type OutputPadId =
  | {
      mixer: MixerNodeId
    }
  | {
      fixed: FixedInstanceNodeId
    }
  | {
      dynamic: DynamicInstanceNodeId
    }
  | {
      track: TrackNodeId
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MixerNodeId".
 */
export type MixerNodeId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "FixedInstanceNodeId".
 */
export type FixedInstanceNodeId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DynamicInstanceNodeId".
 */
export type DynamicInstanceNodeId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackNodeId".
 */
export type TrackNodeId = string
/**
 * A pad that can receive connections on a node inside a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InputPadId".
 */
export type InputPadId =
  | {
      mixer: MixerNodeId
    }
  | {
      fixed: FixedInstanceNodeId
    }
  | {
      dynamic: DynamicInstanceNodeId
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ModelId".
 */
export type ModelId = string
/**
 * Channel count for media items and track nodes
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaChannels".
 */
export type MediaChannels = "mono" | "stereo"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackMediaFormat".
 */
export type TrackMediaFormat = "wave" | "mp3" | "flac" | "wavpack"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaObjectId".
 */
export type MediaObjectId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DesiredInstancePlayState".
 */
export type DesiredInstancePlayState =
  | {
      playing: {
        play_id: PlayId
      }
    }
  | {
      rendering: {
        length: number
        render_id: RenderId
      }
    }
  | {
      stopped: {
        position?: number | null
      }
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RenderId".
 */
export type RenderId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DesiredInstancePowerState".
 */
export type DesiredInstancePowerState = "powered_up" | "shut_down"
/**
 * A desired state for the task play state
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DesiredTaskPlayState".
 */
export type DesiredTaskPlayState =
  | {
      play: RequestPlay
    }
  | {
      render: RequestRender
    }
  | "stopped"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "PlayBitDepth".
 */
export type PlayBitDepth = "24" | "16"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SampleRate".
 */
export type SampleRate = "192" | "96" | "88.2" | "48" | "44.1"
/**
 * Difference stamped in milliseconds since a common epoch, in order to pack most efficiently The epoch in InstancePacket is the created_at field of SessionPacket
 *
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DiffStamped_for_AnyValue".
 */
export type DiffStampedFor_AnyValue = [number, true]
/**
 * Difference stamped in milliseconds since a common epoch, in order to pack most efficiently The epoch in InstancePacket is the created_at field of SessionPacket
 *
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DiffStamped_for_CompressedAudio".
 */
export type DiffStampedFor_CompressedAudio = [number, CompressedAudio]
/**
 * Difference stamped in milliseconds since a common epoch, in order to pack most efficiently The epoch in InstancePacket is the created_at field of SessionPacket
 *
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DiffStamped_for_PadMetering".
 */
export type DiffStampedFor_PadMetering = [number, PadMetering]
/**
 * A message sent over a real-time communication channel to a streaming domain connection
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainClientMessage".
 */
export type DomainClientMessage =
  | {
      request_modify_task_spec: {
        /**
         * List of modifications to apply
         */
        modify_spec: ModifyTaskSpec[]
        /**
         * If true, the modifications are optional (no error if task already diverged)
         */
        optional: boolean
        /**
         * Request id (to reference the response to)
         */
        request_id: RequestId
        /**
         * Task version
         */
        revision: number
        /**
         * Id of the task to modify
         */
        task_id: AppTaskId
      }
    }
  | {
      request_peer_connection: {
        /**
         * Request id (to reference the response to)
         */
        request_id: RequestId
      }
    }
  | {
      answer_peer_connection: {
        /**
         * The domain server's WebRTC offer response (answer)
         */
        answer: string
        /**
         * Request id (to reference the response to)
         */
        request_id: RequestId
        /**
         * The socket for which we are generating an anwser
         */
        socket_id: SocketId
      }
    }
  | {
      submit_peer_connection_candidate: {
        /**
         * ICE Candidate
         */
        candidate?: string | null
        /**
         * Request id (to reference the response to)
         */
        request_id: RequestId
        /**
         * Socket id of the peer connection
         */
        socket_id: SocketId
      }
    }
  | {
      request_attach_to_task: {
        /**
         * Request id (to reference the response to)
         */
        request_id: RequestId
        /**
         * Secure key to use for attachment
         */
        secure_key: SecureKey
        /**
         * Id of the task to attach to
         */
        task_id: AppTaskId
      }
    }
  | {
      request_detach_from_task: {
        /**
         * Request id (to reference the response to)
         */
        request_id: RequestId
        /**
         * Id of the task to attach to
         */
        task_id: AppTaskId
      }
    }
  | {
      pong: {
        challenge: string
        response: string
      }
    }
/**
 * Modify task structure
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ModifyTaskSpec".
 */
export type ModifyTaskSpec =
  | {
      add_track: {
        /**
         * Number of channels for the track node
         */
        channels: MediaChannels
        /**
         * New track node id
         */
        track_id: TrackNodeId
      }
    }
  | {
      add_track_media: {
        /**
         * Media id within the track node
         */
        media_id: TrackMediaId
        /**
         * Media object specification
         */
        spec: TrackMedia
        /**
         * Track node id
         */
        track_id: TrackNodeId
      }
    }
  | {
      update_track_media: {
        /**
         * Media id within the track node
         */
        media_id: TrackMediaId
        /**
         * Track node id
         */
        track_id: TrackNodeId
        /**
         * Media object update
         */
        update: UpdateTaskTrackMedia
      }
    }
  | {
      delete_track_media: {
        /**
         * Media id within the track node
         */
        media_id: TrackMediaId
        /**
         * Track node id
         */
        track_id: TrackNodeId
      }
    }
  | {
      delete_track: {
        /**
         * Track node id
         */
        track_id: TrackNodeId
      }
    }
  | {
      add_fixed_instance: {
        /**
         * Fixed instance node id
         */
        fixed_id: FixedInstanceNodeId
        /**
         * Fixed instance node processing specification
         */
        spec: FixedInstanceNode
      }
    }
  | {
      add_dynamic_instance: {
        /**
         * Dynamic instance node id
         */
        dynamic_id: DynamicInstanceNodeId
        /**
         * Dynamic instance node processing specification
         */
        spec: DynamicInstanceNode
      }
    }
  | {
      add_mixer: {
        /**
         * Mixer node id
         */
        mixer_id: MixerNodeId
        /**
         * Mixer node processing specification
         */
        spec: MixerNode
      }
    }
  | {
      delete_mixer: {
        /**
         * Moxer node id
         */
        mixer_id: MixerNodeId
      }
    }
  | {
      delete_fixed_instance: {
        /**
         * Fixed instance node id
         */
        fixed_id: FixedInstanceNodeId
      }
    }
  | {
      delete_dynamic_instance: {
        /**
         * Dynamic instance node id
         */
        dynamic_id: DynamicInstanceNodeId
      }
    }
  | {
      delete_connection: {
        /**
         * Connection id
         */
        connection_id: NodeConnectionId
      }
    }
  | {
      add_connection: {
        /**
         * Connection id
         */
        connection_id: NodeConnectionId
        /**
         * Source node pad
         */
        from: OutputPadId
        /**
         * Source channel mask
         */
        from_channels: ChannelMask
        /**
         * Panning adjustment on the audio passing through the connection
         */
        pan: number
        /**
         * Destination node pad
         */
        to: InputPadId
        /**
         * Destination channel mask
         */
        to_channels: ChannelMask
        /**
         * Volume adjustment on audio passing through the connection
         */
        volume: number
      }
    }
  | {
      set_connection_parameter_values: {
        /**
         * Connection id
         */
        connection_id: NodeConnectionId
        /**
         * Values (parameters) on the connection
         */
        values: ConnectionValues
      }
    }
  | {
      set_fixed_instance_parameter_values: {
        /**
         * Fixed instance node id
         */
        fixed_id: FixedInstanceNodeId
        /**
         * Values to set
         */
        values: {
          [k: string]: unknown
        }
      }
    }
  | {
      set_dynamic_instance_parameter_values: {
        /**
         * Dynamic instance node id
         */
        dynamic_id: DynamicInstanceNodeId
        /**
         * Values to set
         */
        values: {
          [k: string]: unknown
        }
      }
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackMediaId".
 */
export type TrackMediaId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "NodeConnectionId".
 */
export type NodeConnectionId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestId".
 */
export type RequestId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SecureKey".
 */
export type SecureKey = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainCommand".
 */
export type DomainCommand =
  | {
      create: {
        app_session_id: AppTaskId
        task: Task
      }
    }
  | {
      set_spec: {
        app_session_id: AppTaskId
        spec: TaskSpec
        version: number
      }
    }
  | {
      set_security: {
        app_session_id: AppTaskId
        security: {
          [k: string]: TaskPermissions
        }
        version: number
      }
    }
  | {
      modify: {
        app_session_id: AppTaskId
        modifications: ModifyTaskSpec[]
        version: number
      }
    }
  | {
      set_desired_play_state: {
        app_session_id: AppTaskId
        desired_play_state: DesiredTaskPlayState
        version: number
      }
    }
  | {
      delete: {
        app_session_id: AppTaskId
      }
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainId".
 */
export type DomainId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainError".
 */
export type DomainError =
  | {
      error: InstanceDriverError
      instance_id: FixedInstanceId
      type: "instance_driver"
    }
  | {
      engine_id: EngineId
      error: EngineError
      type: "engine"
    }
  | {
      engine_id: EngineId
      type: "engine_not_found"
    }
  | {
      socket_id: ClientSocketId
      type: "socket_not_found"
    }
  | {
      socket_id: ClientSocketId
      type: "socket_exists"
    }
  | {
      task_id: AppTaskId
      type: "task_not_found"
    }
  | {
      play_id: PlayId
      task_id: AppTaskId
      type: "task_stream_not_found"
    }
  | {
      play_id: PlayId
      serial: number
      task_id: AppTaskId
      type: "task_packet_not_found"
    }
  | {
      task_id: AppTaskId
      type: "task_exists"
    }
  | {
      revision: number
      task_id: AppTaskId
      type: "task_modification_revision_out_of_date"
    }
  | {
      error: ModifyTaskError
      task_id: AppTaskId
      type: "task_modification"
    }
  | {
      instance_id: FixedInstanceId
      type: "instance_not_found"
    }
  | {
      instance_id: FixedInstanceId
      operation: string
      type: "instance_not_capable"
    }
  | {
      media_object_id: AppMediaObjectId
      type: "media_not_found"
    }
  | {
      error: string
      type: "serialization"
    }
  | {
      call: string
      reason: string
      type: "not_implemented"
    }
  | {
      error: string
      type: "bad_gateway"
    }
  | {
      type: "authentication_failed"
    }
  | {
      error: string
      type: "task_revision_malformed"
    }
  | {
      required: TaskPermissions
      task_id: AppTaskId
      type: "task_authtorization_failed"
    }
  | {
      state: TaskPlayStateSummary
      task_id: AppTaskId
      type: "task_illegal_play_state"
    }
  | {
      error: string
      type: "web_r_t_c_error"
    }
  | {
      error: string
      type: "r_p_c"
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InstanceDriverError".
 */
export type InstanceDriverError =
  | ("media_not_present" | "not_power_controller" | "not_interruptable")
  | {
      instance_not_found: {
        instance: FixedInstanceId
      }
    }
  | {
      parameter_does_not_exist: {
        error: string
      }
    }
  | {
      parameters_malformed: {
        error: string
      }
    }
  | {
      reports_malformed: {
        error: string
      }
    }
  | {
      config_malformed: {
        error: string
      }
    }
  | {
      i_o_error: {
        error: string
      }
    }
  | {
      driver_not_supported: {
        manufacturer: string
        name: string
      }
    }
  | {
      r_p_c: {
        error: string
      }
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "EngineId".
 */
export type EngineId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "EngineError".
 */
export type EngineError =
  | {
      track: number
      type: "track_not_found"
    }
  | {
      item: number
      track: number
      type: "item_not_found"
    }
  | {
      error: ModifyTaskError
      task: AppTaskId
      type: "modify_task"
    }
  | {
      error: string
      type: "internal_error"
    }
  | {
      error: string
      type: "r_p_c"
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ModifyTaskError".
 */
export type ModifyTaskError =
  | {
      node_id: TrackNodeId
      type: "track_exists"
    }
  | {
      node_id: FixedInstanceNodeId
      type: "fixed_instance_exists"
    }
  | {
      node_id: DynamicInstanceNodeId
      type: "dynamic_instance_exists"
    }
  | {
      node_id: MixerNodeId
      type: "mixer_exists"
    }
  | {
      node_id: TrackNodeId
      type: "track_does_not_exist"
    }
  | {
      node_id: FixedInstanceNodeId
      type: "fixed_instance_does_not_exist"
    }
  | {
      node_id: DynamicInstanceNodeId
      type: "dynamic_instance_does_not_exist"
    }
  | {
      node_id: MixerNodeId
      type: "mixer_does_not_exist"
    }
  | {
      connection_id: NodeConnectionId
      type: "connection_does_not_exist"
    }
  | {
      connection_id: NodeConnectionId
      type: "connection_exists"
    }
  | {
      connection_id: NodeConnectionId
      message: string
      type: "connection_malformed"
    }
  | {
      media_id: TrackMediaId
      node_id: TrackNodeId
      type: "media_exists"
    }
  | {
      media_id: TrackMediaId
      node_id: TrackNodeId
      type: "media_does_not_exist"
    }
  | {
      type: "cycle_detected"
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskPlayStateSummary".
 */
export type TaskPlayStateSummary =
  | "preparing_to_play"
  | "preparing_to_render"
  | "playing"
  | "rendering"
  | "stopping_play"
  | "stopping_render"
  | "stopped"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainEvent".
 */
export type DomainEvent =
  | {
      fixed_instance: {
        event: InstanceEvent
        instance_id: FixedInstanceId
      }
    }
  | {
      task: {
        event: TaskEvent
        task_id: AppTaskId
      }
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InstanceEvent".
 */
export type InstanceEvent =
  | {
      state: {
        connected: TimestampedFor_Boolean
        play?: ReportInstancePlayState | null
        power?: ReportInstancePowerState | null
      }
    }
  | {
      error: {
        error: string
      }
    }
/**
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Timestamped_for_Boolean".
 */
export type TimestampedFor_Boolean = [string, boolean]
/**
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Timestamped_for_InstancePlayState".
 */
export type TimestampedFor_InstancePlayState = [string, InstancePlayState]
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InstancePlayState".
 */
export type InstancePlayState =
  | "stopping"
  | {
      preparing_to_play: {
        play_id: PlayId
      }
    }
  | {
      playing: {
        play_id: PlayId
      }
    }
  | {
      preparing_to_render: {
        length: number
        render_id: RenderId
      }
    }
  | {
      rendering: {
        length: number
        render_id: RenderId
      }
    }
  | {
      rewinding: {
        to: number
      }
    }
  | {
      stopped: {
        position?: number | null
      }
    }
/**
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Timestamped_for_DesiredInstancePlayState".
 */
export type TimestampedFor_DesiredInstancePlayState = [string, DesiredInstancePlayState]
/**
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Timestamped_for_Nullable_double".
 */
export type TimestampedFor_NullableDouble = [string, number | null]
/**
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Timestamped_for_InstancePowerState".
 */
export type TimestampedFor_InstancePowerState = [string, InstancePowerState]
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InstancePowerState".
 */
export type InstancePowerState = "powering_up" | "shutting_down" | "powered_up" | "shut_down"
/**
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Timestamped_for_DesiredInstancePowerState".
 */
export type TimestampedFor_DesiredInstancePowerState = [string, DesiredInstancePowerState]
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskEvent".
 */
export type TaskEvent =
  | "deleted"
  | {
      play_state: {
        current: TimestampedFor_TaskPlayState
        desired: TimestampedFor_DesiredTaskPlayState
        waiting_instances: FixedInstanceId[]
        waiting_media: AppMediaObjectId[]
      }
    }
  | {
      streaming_packet: {
        packet: StreamingPacket
      }
    }
/**
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Timestamped_for_TaskPlayState".
 */
export type TimestampedFor_TaskPlayState = [string, TaskPlayState]
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskPlayState".
 */
export type TaskPlayState =
  | "stopped"
  | {
      preparing_to_play: RequestPlay
    }
  | {
      preparing_to_render: RequestRender
    }
  | {
      playing: RequestPlay
    }
  | {
      rendering: RequestRender
    }
  | {
      stopping_play: PlayId
    }
  | {
      stopping_render: RenderId
    }
/**
 * @minItems 2
 * @maxItems 2
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Timestamped_for_DesiredTaskPlayState".
 */
export type TimestampedFor_DesiredTaskPlayState = [string, DesiredTaskPlayState]
/**
 * A mesasge received over a real-time communication channel from a streaming domain connection
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainServerMessage".
 */
export type DomainServerMessage =
  | {
      task_event: {
        /**
         * Event details
         */
        event: TaskEvent
        /**
         * Id of the task generating the event
         */
        task_id: AppTaskId
      }
    }
  | {
      set_desired_play_state_response: {
        /**
         * Request id this message is responding to
         */
        request_id: RequestId
        /**
         * Result
         */
        result: SerializableResultFor_TaskUpdatedAnd_DomainError
      }
    }
  | {
      modify_task_spec_response: {
        /**
         * Request id this message is responding to
         */
        request_id: RequestId
        /**
         * Result of the operation
         */
        result: SerializableResultFor_TaskUpdatedAnd_DomainError
      }
    }
  | {
      peer_connection_response: {
        /**
         * Request id this message is responding to
         */
        request_id: RequestId
        /**
         * Result of the operation - the assigned socket ID
         */
        result: SerializableResultFor_PeerConnectionCreatedAnd_DomainError
      }
    }
  | {
      answer_peer_connection_response: {
        /**
         * Request id this message is responding to
         */
        request_id: RequestId
        /**
         * Result of the operation or error
         */
        result: SerializableResultFor_NullAnd_DomainError
      }
    }
  | {
      peer_connection_candidate_response: {
        /**
         * Request id this message is responding to
         */
        request_id: RequestId
        /**
         * Result of the operation
         */
        result: SerializableResultFor_NullAnd_DomainError
      }
    }
  | {
      attach_to_task_response: {
        /**
         * Request id this message is responding to
         */
        request_id: RequestId
        /**
         * Result of the operation
         */
        result: SerializableResultFor_NullAnd_DomainError
      }
    }
  | {
      detach_from_task_response: {
        /**
         * Request id this message is responding to
         */
        request_id: RequestId
        /**
         * Result of the operation - will be success even if task does not exist
         */
        result: SerializableResultFor_NullAnd_DomainError
      }
    }
  | {
      submit_peer_connection_candidate: {
        /**
         * ICE Candidate
         */
        candidate?: string | null
        /**
         * Socket id of the peer connection
         */
        socket_id: SocketId
      }
    }
  | {
      ping: {
        /**
         * Challenge string
         *
         * In a future release, this field will contain a challenge that must be processed and returned to validate that the client is running a valid version of the client code
         */
        challenge: string
      }
    }
  | {
      notify_task_permissions: {
        /**
         * Mapping from each available task to permission information to that task
         */
        permissions: {
          [k: string]: TaskPermissions
        }
      }
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SerializableResult_for_TaskUpdated_and_DomainError".
 */
export type SerializableResultFor_TaskUpdatedAnd_DomainError =
  | {
      ok: TaskUpdated
    }
  | {
      error: DomainError
    }
/**
 * Response to modifying a task on the domain
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskUpdated".
 */
export type TaskUpdated =
  | {
      updated: {
        /**
         * New version to be used with `If-Matches` when submitting further modifications
         */
        revision: number
        /**
         * Task Id
         */
        task_id: AppTaskId
      }
    }
  | {
      ignored: {
        /**
         * Current version to be used with `If-Matches` when submitting further modifications
         */
        revision: number
        /**
         * Task Id
         */
        task_id: AppTaskId
      }
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SerializableResult_for_PeerConnectionCreated_and_DomainError".
 */
export type SerializableResultFor_PeerConnectionCreatedAnd_DomainError =
  | {
      ok: PeerConnectionCreated
    }
  | {
      error: DomainError
    }
/**
 * Confirmation that the socket has been created normally from the domain client offer
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "PeerConnectionCreated".
 */
export type PeerConnectionCreated = {
  created: {
    /**
     * The domain server's WebRTC offer
     */
    remote_description: string
    /**
     * Created socket id
     */
    socket_id: ClientSocketId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SerializableResult_for_Null_and_DomainError".
 */
export type SerializableResultFor_NullAnd_DomainError =
  | {
      ok: null
    }
  | {
      error: DomainError
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InstanceDriverId".
 */
export type InstanceDriverId = string
/**
 * Response to creating a task on the domain
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskCreated".
 */
export type TaskCreated = {
  created: {
    /**
     * Task Id
     */
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskDeleted".
 */
export type TaskDeleted = {
  deleted: {
    id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskId".
 */
export type TaskId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskPlayStopped".
 */
export type TaskPlayStopped = {
  stopped: {
    play_id: PlayId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskPlaying".
 */
export type TaskPlaying = {
  playing: {
    play_id: PlayId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskRenderCancelled".
 */
export type TaskRenderCancelled = {
  cancelled: {
    render_id: RenderId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskRendering".
 */
export type TaskRendering = {
  rendering: {
    render_id: RenderId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskSought".
 */
export type TaskSought = {
  sought: {
    play_id: PlayId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskSummaryList".
 */
export type TaskSummaryList = TaskSummary[]

export interface CloudApi {
  [k: string]: unknown
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ClientSocketId".
 */
export interface ClientSocketId {
  client_id: ClientId
  socket_id: SocketId
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "CompressedAudio".
 */
export interface CompressedAudio {
  buffer: number[]
  last: boolean
  num_samples: number
  play_id: PlayId
  stream_pos: number
  timeline_pos: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ConnectionValues".
 */
export interface ConnectionValues {
  pan?: number | null
  volume?: number | null
}
/**
 * Create a task on the domain
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "CreateTask".
 */
export interface CreateTask {
  /**
   * Task reservations
   */
  reservations: CreateTaskReservation
  /**
   * Security keys and associateds permissions
   */
  security: {
    [k: string]: TaskPermissions
  }
  /**
   * Task specification
   */
  spec: CreateTaskSpec
  /**
   * The new app id
   */
  task_id: AppTaskId
}
/**
 * Timed resource reservations for the task (must contain all used resources)
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "CreateTaskReservation".
 */
export interface CreateTaskReservation {
  /**
   * Fixed instances reserved for the task
   */
  fixed_instances: FixedInstanceId[]
  /**
   * Start of the reservation time
   */
  from: string
  /**
   * End of the reservation time
   */
  to: string
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskPermissions".
 */
export interface TaskPermissions {
  audio: boolean
  media: boolean
  parameters: boolean
  structure: boolean
  transport: boolean
}
/**
 * Create task spec
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "CreateTaskSpec".
 */
export interface CreateTaskSpec {
  /**
   * Connections between nodes
   */
  connections?: {
    [k: string]: NodeConnection
  }
  /**
   * Dynamic instance nodes of the task
   */
  dynamic?: {
    [k: string]: DynamicInstanceNode
  }
  /**
   * Fixed instance nodes of the task
   */
  fixed?: {
    [k: string]: FixedInstanceNode
  }
  /**
   * Mixer nodes of the task
   */
  mixers?: {
    [k: string]: MixerNode
  }
  /**
   * Track nodes of the task
   */
  tracks?: {
    [k: string]: TrackNode
  }
}
/**
 * Connection between nodes in a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "NodeConnection".
 */
export interface NodeConnection {
  /**
   * Source node pad
   */
  from: OutputPadId
  /**
   * Source channel mask
   */
  from_channels: ChannelMask
  /**
   * Panning adjustment
   *
   * Zero is centered, -1 is fully left, 1 is fully right
   */
  pan: number
  /**
   * Destination node pad
   */
  to: InputPadId
  /**
   * Destination channel mask
   */
  to_channels: ChannelMask
  /**
   * Volume adjustment as a factor
   */
  volume: number
}
/**
 * Dynamic node specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DynamicInstanceNode".
 */
export interface DynamicInstanceNode {
  /**
   * The manufacturer and name of the processing software
   */
  model_id: ModelId
  /**
   * Parameter values
   */
  parameters: {
    [k: string]: unknown
  }
}
/**
 * Fixed instance node specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "FixedInstanceNode".
 */
export interface FixedInstanceNode {
  /**
   * The manufacturer, name and instance identifier of the hardware device doing the processing
   */
  instance_id: FixedInstanceId
  /**
   * parameters
   */
  parameters: {
    [k: string]: unknown
  }
  /**
   * Dry-wet percentage
   *
   * only applicable for instances with same number of inputs and outputs, having 1 or 2 channels.
   */
  wet: number
}
/**
 * Mixer node specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MixerNode".
 */
export interface MixerNode {
  /**
   * Numvber of input channels on the mixer node
   */
  input_channels: number
  /**
   * Number of output channels on the mixer node
   */
  output_channels: number
}
/**
 * Track node specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackNode".
 */
export interface TrackNode {
  /**
   * Number of channels
   */
  channels: MediaChannels
  /**
   * Media items present on the track
   */
  media: {
    [k: string]: TrackMedia
  }
}
/**
 * Media item specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackMedia".
 */
export interface TrackMedia {
  /**
   * Number of channels
   */
  channels: MediaChannels
  /**
   * Media format
   */
  format: TrackMediaFormat
  /**
   * Subset of media that is used
   */
  media_segment: TimeSegment
  /**
   * Source media object id
   */
  object_id: MediaObjectId
  /**
   * Where to place the media in the task timeline
   */
  timeline_segment: TimeSegment
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TimeSegment".
 */
export interface TimeSegment {
  length: number
  start: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestPlay".
 */
export interface RequestPlay {
  bit_depth: PlayBitDepth
  looping: boolean
  mixer_id: MixerNodeId
  play_id: PlayId
  sample_rate: SampleRate
  segment: TimeSegment
  start_at: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestRender".
 */
export interface RequestRender {
  mixer_id: MixerNodeId
  object_id: AppMediaObjectId
  render_id: RenderId
  segment: TimeSegment
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "PadMetering".
 */
export interface PadMetering {
  volume: number[]
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "UpdateTaskTrackMedia".
 */
export interface UpdateTaskTrackMedia {
  channels?: MediaChannels | null
  media_segment?: TimeSegment | null
  object_id?: MediaObjectId | null
  timeline_segment?: TimeSegment | null
}
/**
 * Task information
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Task".
 */
export interface Task {
  /**
   * Domain executing the task
   */
  domain_id: DomainId
  /**
   * Task reservations
   */
  reservations: TaskReservation
  /**
   * Security keys and associateds permissions
   */
  security: TaskSecurity
  /**
   * Task specification
   */
  spec: TaskSpec
}
/**
 * Timed resource reservations for the task (must contain all used resources)
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskReservation".
 */
export interface TaskReservation {
  /**
   * Fixed instances reserved for the task
   */
  fixed_instances: FixedInstanceId[]
  /**
   * Start of the reservation time
   */
  from: string
  /**
   * Revision number - starts at zero and change of task reservation increments it
   */
  revision: number
  /**
   * End of the reservation time
   */
  to: string
}
/**
 * Information about access keys and permissions of a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskSecurity".
 */
export interface TaskSecurity {
  /**
   * Revision number - starts at zero and is incremented at every change of task security
   */
  revision?: number
  /**
   * Security settings per secure key
   */
  security: {
    [k: string]: TaskPermissions
  }
}
/**
 * Task specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskSpec".
 */
export interface TaskSpec {
  /**
   * Connections between nodes
   */
  connections?: {
    [k: string]: NodeConnection
  }
  /**
   * Dynamic instance nodes of the task
   */
  dynamic?: {
    [k: string]: DynamicInstanceNode
  }
  /**
   * Fixed instance nodes of the task
   */
  fixed?: {
    [k: string]: FixedInstanceNode
  }
  /**
   * Mixer nodes of the task
   */
  mixers?: {
    [k: string]: MixerNode
  }
  /**
   * The revision number of the specification (starts at zero, increments for every change)
   */
  revision?: number
  /**
   * Track nodes of the task
   */
  tracks?: {
    [k: string]: TrackNode
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ReportInstancePlayState".
 */
export interface ReportInstancePlayState {
  actual: TimestampedFor_InstancePlayState
  desired: TimestampedFor_DesiredInstancePlayState
  media: TimestampedFor_NullableDouble
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ReportInstancePowerState".
 */
export interface ReportInstancePowerState {
  actual: TimestampedFor_InstancePowerState
  desired: TimestampedFor_DesiredInstancePowerState
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "StreamingPacket".
 */
export interface StreamingPacket {
  audio: DiffStampedFor_CompressedAudio[]
  created_at: string
  instance_metering: {
    [k: string]: DiffStampedFor_AnyValue[]
  }
  pad_metering: {
    [k: string]: DiffStampedFor_PadMetering[]
  }
  play_id: PlayId
  serial: number
  streaming_pos: number
  timeline_pos: number
}
/**
 * Configuration of how a fixed instance is connected to the domain
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainFixedInstanceEngine".
 */
export interface DomainFixedInstanceEngine {
  /**
   * Engine hosting the instance, if any
   */
  engine_id: EngineId
  /**
   * Instance inputs start at index on engine
   */
  input_start: number
  /**
   * Instance outputs start at index on engine
   */
  output_start: number
}
/**
 * Instance media settings
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainMediaInstanceConfig".
 */
export interface DomainMediaInstanceConfig {
  /**
   * Lenght of the inserted media in milliseconds
   */
  length_ms: number
  /**
   * Behaviour of playing back (streaming) and hitting end of media
   *
   * - If null, rewind to start - Otherwise, rewind by specified amount of milliseconds
   */
  play_rewind?: number | null
  /**
   * WHen rewinding to make space for contiguous renders, should the driver rewind to start or just enough to start rendering
   */
  renders_rewind_to_start: boolean
}
/**
 * Instance power settings
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DomainPowerInstanceConfig".
 */
export interface DomainPowerInstanceConfig {
  /**
   * Which channel on the power instance is distributing power to this instance
   */
  channel: number
  /**
   * Number of milliseconds to wait to cool down after powering down
   */
  cool_down_ms?: number
  /**
   * Number of milliseconds to wait before automatically powering down after idle
   */
  idle_off_delay_ms?: number
  /**
   * Power instance used to distribute power to this instance
   */
  instance: FixedInstanceId
  /**
   * Number of milliseconds to wait to warm up after powering on
   */
  warm_up_ms?: number
}
/**
 * Limits on dynamic instances
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DynamicInstanceLimits".
 */
export interface DynamicInstanceLimits {
  /**
   * Maximum number of concurrent dynamic instances
   *
   * Takes precedence over over total resource usage. For example, there may be more resources but licensing limits the amount of instances.
   */
  max_instances: number
}
/**
 * Information about a media engine within a domain
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "EngineConfig".
 */
export interface EngineConfig {
  /**
   * Additional configuration, specific to the engine configuration
   */
  additional?: {
    [k: string]: unknown
  }
  /**
   * Dynamic instances configured on the audio engine, with associated limits
   */
  dynamic_instances?: {
    [k: string]: DynamicInstanceLimits
  }
  /**
   * Maximum number of concurrent tasks
   */
  max_concurrent_tasks: number
  /**
   * Resources available on the domain
   */
  resources?: {
    [k: string]: number
  }
  /**
   * Native audio sample rate
   */
  sample_rate: number
}
/**
 * Configuration of a fixed instance
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "FixedInstanceConfig".
 */
export interface FixedInstanceConfig {
  /**
   * Additional information specific to the driver implementation
   */
  additional?: {
    [k: string]: unknown
  }
  /**
   * Apps allowed to access the instance or null if the domain defaults are used
   */
  apps_override?: AppId[] | null
  /**
   * Which driver is using
   */
  driver?: InstanceDriverId | null
  /**
   * Configuration of how a fixed instance is connected to the domain
   */
  engine?: DomainFixedInstanceEngine | null
  /**
   * Maintenance windows on this instance
   */
  maintenance?: Maintenance[]
  /**
   * Optional configuration if instance handles media (such as tape machines)
   */
  media?: DomainMediaInstanceConfig | null
  /**
   * Optional configuration to powers on/off instance to conserve energy
   */
  power?: DomainPowerInstanceConfig | null
  /**
   * Additional models with parameters or reports that are merged with the instance model
   */
  sidecars?: ModelId[]
}
/**
 * Maintenance window
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "Maintenance".
 */
export interface Maintenance {
  /**
   * Human readable string about it, or URL to a web page detailing more information
   */
  reason: string
  /**
   * Time during which maintenance is taking place (may overlap with others)
   */
  time: TimeRange
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TimeRange".
 */
export interface TimeRange {
  from: string
  to: string
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InstanceDriverConfig".
 */
export interface InstanceDriverConfig {
  instances: {
    [k: string]: FixedInstanceConfig
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaMetadata".
 */
export interface MediaMetadata {
  bytes: number
  channels: MediaChannels
  format: TrackMediaFormat
  sample_rate: number
  seconds: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaObject".
 */
export interface MediaObject {
  id: AppMediaObjectId
  last_used?: string | null
  metadata?: MediaMetadata | null
  path?: string | null
  revision: number
}
/**
 * Request to modify a task on the domain
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ModifyTask".
 */
export interface ModifyTask {
  /**
   * A list of modifications to apply
   */
  modify_spec: ModifyTaskSpec[]
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestCancelRender".
 */
export interface RequestCancelRender {
  render_id: RenderId
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestChangeMixer".
 */
export interface RequestChangeMixer {
  mixer_id: MixerNodeId
  play_id: PlayId
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestSeek".
 */
export interface RequestSeek {
  looping: boolean
  play_id: PlayId
  segment: TimeSegment
  start_at: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestStopPlay".
 */
export interface RequestStopPlay {
  play_id: PlayId
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "StreamStats".
 */
export interface StreamStats {
  high?: number | null
  id: AppTaskId
  low?: number | null
  play_id: PlayId
  state: TaskPlayState
}
/**
 * A summary of a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskSummary".
 */
export interface TaskSummary {
  /**
   * Current play sate
   */
  play_state: TaskPlayState
  /**
   * Task Id
   */
  task_id: AppTaskId
  /**
   * List of instances that are blocking play state change
   */
  waiting_for_instances: FixedInstanceId[]
  /**
   * List of media that are blocking or influencing completeness of play state change
   */
  waiting_for_media: AppMediaObjectId[]
}
/**
 * A more complete information about a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskWithStatusAndSpec".
 */
export interface TaskWithStatusAndSpec {
  /**
   * State of attatched fixed instances
   */
  instances: {
    [k: string]: InstancePlayState
  }
  /**
   * State of attached media objects
   */
  media: {
    [k: string]: MediaObject
  }
  /**
   * Current play state
   */
  play_state: TaskPlayState
  /**
   * The current specification of the task
   */
  spec: TaskSpec
  /**
   * Task Id
   */
  task_id: AppTaskId
}
export class Client {
  constructor(private readonly requester: Requester) {}
  /**
   * Register an audio engine
   *
   * This endpoint is used to register an audio engine with the Domain Server. It will provide its known configuration
   * and expect to return an updated (merged) configuration that includes any configuration that the domain server knows.
   *
   * @param engine_id The ID of the engine to register
   * @param body Request body
   */
  async register_engine(engine_id: EngineId, body: EngineConfig): Promise<Result<EngineConfig, DomainError>> {
    return this.requester.request({
      path: `/v1/engines/${engine_id}/register`,
      method: "post",
      body: body,
      headers: {},
    })
  }
  /**
   * Register a fixed instance driver
   *
   * This endpoint is used to register a fixed instance driver with the Domain Server. It will provide its known configuration
   * and expect to return an updated (merged) configuration that includes any configuration that the domain server knows.
   *
   * @param driver_id The manufacturer of the driver
   */
  async register_fixed_instance_driver(
    driver_id: InstanceDriverId
  ): Promise<Result<InstanceDriverConfig, DomainError>> {
    return this.requester.request({ path: `/v1/drivers/${driver_id}/register`, method: "post", headers: {} })
  }
  /**
   * Get stream statistics
   *
   * Get statistics about cached packets available in the stream.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param play_id Play id
   */
  async stream_stats(app_id: AppId, task_id: TaskId, play_id: PlayId): Promise<Result<StreamStats, DomainError>> {
    return this.requester.request({ path: `/v1/streams/${app_id}/${task_id}/${play_id}`, method: "get", headers: {} })
  }
  /**
   * Load packet data
   *
   * For each PlayId, on a task, a stream is kept in memory with a history of packets, by ascending
   * serial number. For a sane amount of time, the packets may be requested by the clients. If a
   * packet is not yet models (but it is expected they will be, in the future) the request will
   * block (wait) for `Timeout` milliseconds before giving up and returning 408.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param play_id Play id
   * @param serial Packet serial number
   * @param timeout Milliseconds to wait for the packet to be ready
   */
  async stream_packets(
    app_id: AppId,
    task_id: TaskId,
    play_id: PlayId,
    serial: number,
    timeout: number
  ): Promise<Result<StreamingPacket, DomainError>> {
    return this.requester.request({
      path: `/v1/streams/${app_id}/${task_id}/${play_id}/packet/${serial}`,
      method: "get",
      headers: { Timeout: timeout },
    })
  }
  /**
   * List tasks
   *
   * Return a list of all current tasks and their status.
   *
   */
  async list_tasks(): Promise<Result<TaskSummaryList, DomainError>> {
    return this.requester.request({ path: `/v1/tasks`, method: "get", headers: {} })
  }
  /**
   * Create a task
   *
   * In standalone mode, the task will be checked for mutual exclusivity with other tasks, otherwise
   * it will be created. This call could also fail if the referenced resources (such as fixed
   * instances) do not exist.
   *
   * @param body Request body
   */
  async create_task(body: CreateTask): Promise<Result<TaskCreated, DomainError>> {
    return this.requester.request({ path: `/v1/tasks`, method: "post", body: body, headers: {} })
  }
  /**
   * Delete a task
   *
   * Delete a task and release all referenced resources.
   *
   * @param app_id App id
   * @param task_id Task id
   */
  async delete_task(app_id: AppId, task_id: TaskId): Promise<Result<TaskDeleted, DomainError>> {
    return this.requester.request({ path: `/v1/tasks/${app_id}/${task_id}`, method: "delete", headers: {} })
  }
  /**
   * Get task details
   *
   * Get details of a task, including dependent media and instance statuses
   *
   * @param app_id App id
   * @param task_id Task id
   */
  async get_task(app_id: AppId, task_id: TaskId): Promise<Result<TaskWithStatusAndSpec, DomainError>> {
    return this.requester.request({ path: `/v1/tasks/${app_id}/${task_id}`, method: "get", headers: {} })
  }
  /**
   * Modify existing task
   *
   * Submit modifications to the task. This generic request can be used to update most aspects of the
   * session: adjusting parameters, creating, deleting, reconnecting nodes, changing media, etc.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param if_match The task version to be changed
   * @param body Request body
   */
  async modify_task(
    app_id: AppId,
    task_id: TaskId,
    if_match: number,
    body: ModifyTask
  ): Promise<Result<TaskUpdated, DomainError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/modify`,
      method: "post",
      body: body,
      headers: { "If-Match": if_match },
    })
  }
  /**
   * Cancel rendering a task
   *
   * Request to stop (cancel) rendering if the task is rendering.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param if_match The task version
   * @param body Request body
   */
  async cancel_render_task(
    app_id: AppId,
    task_id: TaskId,
    if_match: number,
    body: RequestCancelRender
  ): Promise<Result<TaskRenderCancelled, DomainError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/cancel`,
      method: "post",
      body: body,
      headers: { "If-Match": if_match },
    })
  }
  /**
   * Start playing a task
   *
   * Start playing a task that is stopped. The request will return when the task has started to play
   * or with an error.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param if_match The task version
   * @param body Request body
   */
  async play_task(
    app_id: AppId,
    task_id: TaskId,
    if_match: number,
    body: RequestPlay
  ): Promise<Result<TaskPlaying, DomainError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/play`,
      method: "post",
      body: body,
      headers: { "If-Match": if_match },
    })
  }
  /**
   * Render a task to a new file
   *
   * The domain will check that
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async render_task(app_id: AppId, task_id: TaskId, body: RequestRender): Promise<Result<TaskRendering, DomainError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/render`,
      method: "post",
      body: body,
      headers: {},
    })
  }
  /**
   * Seek while task is playing
   *
   * If the task is playing, change the playing position.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async seek_task(app_id: AppId, task_id: TaskId, body: RequestSeek): Promise<Result<TaskSought, DomainError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/seek`,
      method: "post",
      body: body,
      headers: {},
    })
  }
  /**
   * Stop playing a task
   *
   * Request to stop a track if the task is playing.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param if_match The task version
   * @param body Request body
   */
  async stop_playing_task(
    app_id: AppId,
    task_id: TaskId,
    if_match: number,
    body: RequestStopPlay
  ): Promise<Result<TaskPlayStopped, DomainError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/stop`,
      method: "post",
      body: body,
      headers: { "If-Match": if_match },
    })
  }
}
