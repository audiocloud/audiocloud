import { Requester, Result } from "./base"
export * from "./base"
/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "AppId".
 */
export type AppId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "AppMediaObjectId".
 */
export type AppMediaObjectId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "AppTaskId".
 */
export type AppTaskId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ChannelMask".
 */
export type ChannelMask =
  | {
      mono: number
    }
  | {
      stereo: number
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ModelId".
 */
export type ModelId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DynamicInstanceNodeId".
 */
export type DynamicInstanceNodeId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "EngineError".
 */
export type EngineError =
  | {
      track: number
      type: "track_not_found"
    }
  | {
      item: number
      track: number
      type: "item_not_found"
    }
  | {
      error: ModifyTaskError
      task: AppTaskId
      type: "modify_task"
    }
  | {
      error: string
      type: "internal_error"
    }
  | {
      error: string
      type: "r_p_c"
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ModifyTaskError".
 */
export type ModifyTaskError =
  | {
      node_id: TrackNodeId
      type: "track_exists"
    }
  | {
      node_id: FixedInstanceNodeId
      type: "fixed_instance_exists"
    }
  | {
      node_id: DynamicInstanceNodeId
      type: "dynamic_instance_exists"
    }
  | {
      node_id: MixerNodeId
      type: "mixer_exists"
    }
  | {
      node_id: TrackNodeId
      type: "track_does_not_exist"
    }
  | {
      node_id: FixedInstanceNodeId
      type: "fixed_instance_does_not_exist"
    }
  | {
      node_id: DynamicInstanceNodeId
      type: "dynamic_instance_does_not_exist"
    }
  | {
      node_id: MixerNodeId
      type: "mixer_does_not_exist"
    }
  | {
      connection_id: NodeConnectionId
      type: "connection_does_not_exist"
    }
  | {
      connection_id: NodeConnectionId
      type: "connection_exists"
    }
  | {
      connection_id: NodeConnectionId
      message: string
      type: "connection_malformed"
    }
  | {
      media_id: TrackMediaId
      node_id: TrackNodeId
      type: "media_exists"
    }
  | {
      media_id: TrackMediaId
      node_id: TrackNodeId
      type: "media_does_not_exist"
    }
  | {
      type: "cycle_detected"
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackNodeId".
 */
export type TrackNodeId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "FixedInstanceNodeId".
 */
export type FixedInstanceNodeId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MixerNodeId".
 */
export type MixerNodeId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "NodeConnectionId".
 */
export type NodeConnectionId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackMediaId".
 */
export type TrackMediaId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "FixedInstanceId".
 */
export type FixedInstanceId = string
/**
 * A pad that can receive connections on a node inside a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InputPadId".
 */
export type InputPadId =
  | {
      mixer: MixerNodeId
    }
  | {
      fixed: FixedInstanceNodeId
    }
  | {
      dynamic: DynamicInstanceNodeId
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "InstancesUpdated".
 */
export type InstancesUpdated = {
  updated: {
    added: number
    deleted: number
    replaced: number
  }
}
/**
 * Channel count for media items and track nodes
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaChannels".
 */
export type MediaChannels = "mono" | "stereo"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackMediaFormat".
 */
export type TrackMediaFormat = "wave" | "mp3" | "flac" | "wavpack"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaObjectId".
 */
export type MediaObjectId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaUpdated".
 */
export type MediaUpdated = {
  updated: {
    added: number
    deleted: number
    replaced: number
  }
}
/**
 * Modify task structure
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ModifyTaskSpec".
 */
export type ModifyTaskSpec =
  | {
      add_track: {
        /**
         * Number of channels for the track node
         */
        channels: MediaChannels
        /**
         * New track node id
         */
        track_id: TrackNodeId
      }
    }
  | {
      add_track_media: {
        /**
         * Media id within the track node
         */
        media_id: TrackMediaId
        /**
         * Media object specification
         */
        spec: TrackMedia
        /**
         * Track node id
         */
        track_id: TrackNodeId
      }
    }
  | {
      update_track_media: {
        /**
         * Media id within the track node
         */
        media_id: TrackMediaId
        /**
         * Track node id
         */
        track_id: TrackNodeId
        /**
         * Media object update
         */
        update: UpdateTaskTrackMedia
      }
    }
  | {
      delete_track_media: {
        /**
         * Media id within the track node
         */
        media_id: TrackMediaId
        /**
         * Track node id
         */
        track_id: TrackNodeId
      }
    }
  | {
      delete_track: {
        /**
         * Track node id
         */
        track_id: TrackNodeId
      }
    }
  | {
      add_fixed_instance: {
        /**
         * Fixed instance node id
         */
        fixed_id: FixedInstanceNodeId
        /**
         * Fixed instance node processing specification
         */
        spec: FixedInstanceNode
      }
    }
  | {
      add_dynamic_instance: {
        /**
         * Dynamic instance node id
         */
        dynamic_id: DynamicInstanceNodeId
        /**
         * Dynamic instance node processing specification
         */
        spec: DynamicInstanceNode
      }
    }
  | {
      add_mixer: {
        /**
         * Mixer node id
         */
        mixer_id: MixerNodeId
        /**
         * Mixer node processing specification
         */
        spec: MixerNode
      }
    }
  | {
      delete_mixer: {
        /**
         * Moxer node id
         */
        mixer_id: MixerNodeId
      }
    }
  | {
      delete_fixed_instance: {
        /**
         * Fixed instance node id
         */
        fixed_id: FixedInstanceNodeId
      }
    }
  | {
      delete_dynamic_instance: {
        /**
         * Dynamic instance node id
         */
        dynamic_id: DynamicInstanceNodeId
      }
    }
  | {
      delete_connection: {
        /**
         * Connection id
         */
        connection_id: NodeConnectionId
      }
    }
  | {
      add_connection: {
        /**
         * Connection id
         */
        connection_id: NodeConnectionId
        /**
         * Source node pad
         */
        from: OutputPadId
        /**
         * Source channel mask
         */
        from_channels: ChannelMask
        /**
         * Panning adjustment on the audio passing through the connection
         */
        pan: number
        /**
         * Destination node pad
         */
        to: InputPadId
        /**
         * Destination channel mask
         */
        to_channels: ChannelMask
        /**
         * Volume adjustment on audio passing through the connection
         */
        volume: number
      }
    }
  | {
      set_connection_parameter_values: {
        /**
         * Connection id
         */
        connection_id: NodeConnectionId
        /**
         * Values (parameters) on the connection
         */
        values: ConnectionValues
      }
    }
  | {
      set_fixed_instance_parameter_values: {
        /**
         * Fixed instance node id
         */
        fixed_id: FixedInstanceNodeId
        /**
         * Values to set
         */
        values: {
          [k: string]: unknown
        }
      }
    }
  | {
      set_dynamic_instance_parameter_values: {
        /**
         * Dynamic instance node id
         */
        dynamic_id: DynamicInstanceNodeId
        /**
         * Values to set
         */
        values: {
          [k: string]: unknown
        }
      }
    }
/**
 * A pad that can receive connections on a node inside a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "OutputPadId".
 */
export type OutputPadId =
  | {
      mixer: MixerNodeId
    }
  | {
      fixed: FixedInstanceNodeId
    }
  | {
      dynamic: DynamicInstanceNodeId
    }
  | {
      track: TrackNodeId
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "PlayBitDepth".
 */
export type PlayBitDepth = "24" | "16"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "PlayId".
 */
export type PlayId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RenderId".
 */
export type RenderId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SampleRate".
 */
export type SampleRate = "192" | "96" | "88.2" | "48" | "44.1"
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskDeleted".
 */
export type TaskDeleted = {
  deleted: {
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskId".
 */
export type TaskId = string
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskModified".
 */
export type TaskModified = {
  modified: {
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskPlayState".
 */
export type TaskPlayState =
  | "stopped"
  | {
      preparing_to_play: RequestPlay
    }
  | {
      preparing_to_render: RequestRender
    }
  | {
      playing: RequestPlay
    }
  | {
      rendering: RequestRender
    }
  | {
      stopping_play: PlayId
    }
  | {
      stopping_render: RenderId
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskPlayStopped".
 */
export type TaskPlayStopped = {
  stopped: {
    play_id: PlayId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskPlaying".
 */
export type TaskPlaying = {
  playing: {
    play_id: PlayId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskRenderCancelled".
 */
export type TaskRenderCancelled = {
  cancelled: {
    render_id: RenderId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskRendering".
 */
export type TaskRendering = {
  rendering: {
    render_id: RenderId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskReplaced".
 */
export type TaskReplaced =
  | {
      updated: {
        task_id: AppTaskId
      }
    }
  | {
      created: {
        task_id: AppTaskId
      }
    }
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskSought".
 */
export type TaskSought = {
  sought: {
    play_id: PlayId
    task_id: AppTaskId
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskWithStatusList".
 */
export type TaskWithStatusList = TaskWithStatus[]

export interface CloudApi {
  [k: string]: unknown
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "ConnectionValues".
 */
export interface ConnectionValues {
  pan?: number | null
  volume?: number | null
}
/**
 * Dynamic node specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "DynamicInstanceNode".
 */
export interface DynamicInstanceNode {
  /**
   * The manufacturer and name of the processing software
   */
  model_id: ModelId
  /**
   * Parameter values
   */
  parameters: {
    [k: string]: unknown
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "EngineFixedInstance".
 */
export interface EngineFixedInstance {
  input_start: number
  num_inputs: number
  num_outputs: number
  output_start: number
}
/**
 * Fixed instance node specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "FixedInstanceNode".
 */
export interface FixedInstanceNode {
  /**
   * The manufacturer, name and instance identifier of the hardware device doing the processing
   */
  instance_id: FixedInstanceId
  /**
   * parameters
   */
  parameters: {
    [k: string]: unknown
  }
  /**
   * Dry-wet percentage
   *
   * only applicable for instances with same number of inputs and outputs, having 1 or 2 channels.
   */
  wet: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaMetadata".
 */
export interface MediaMetadata {
  bytes: number
  channels: MediaChannels
  format: TrackMediaFormat
  sample_rate: number
  seconds: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MediaObject".
 */
export interface MediaObject {
  id: AppMediaObjectId
  last_used?: string | null
  metadata?: MediaMetadata | null
  path?: string | null
  revision: number
}
/**
 * Mixer node specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "MixerNode".
 */
export interface MixerNode {
  /**
   * Numvber of input channels on the mixer node
   */
  input_channels: number
  /**
   * Number of output channels on the mixer node
   */
  output_channels: number
}
/**
 * Media item specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackMedia".
 */
export interface TrackMedia {
  /**
   * Number of channels
   */
  channels: MediaChannels
  /**
   * Media format
   */
  format: TrackMediaFormat
  /**
   * Subset of media that is used
   */
  media_segment: TimeSegment
  /**
   * Source media object id
   */
  object_id: MediaObjectId
  /**
   * Where to place the media in the task timeline
   */
  timeline_segment: TimeSegment
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TimeSegment".
 */
export interface TimeSegment {
  length: number
  start: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "UpdateTaskTrackMedia".
 */
export interface UpdateTaskTrackMedia {
  channels?: MediaChannels | null
  media_segment?: TimeSegment | null
  object_id?: MediaObjectId | null
  timeline_segment?: TimeSegment | null
}
/**
 * Connection between nodes in a task
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "NodeConnection".
 */
export interface NodeConnection {
  /**
   * Source node pad
   */
  from: OutputPadId
  /**
   * Source channel mask
   */
  from_channels: ChannelMask
  /**
   * Panning adjustment
   *
   * Zero is centered, -1 is fully left, 1 is fully right
   */
  pan: number
  /**
   * Destination node pad
   */
  to: InputPadId
  /**
   * Destination channel mask
   */
  to_channels: ChannelMask
  /**
   * Volume adjustment as a factor
   */
  volume: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestCancelRender".
 */
export interface RequestCancelRender {
  render_id: RenderId
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestChangeMixer".
 */
export interface RequestChangeMixer {
  mixer_id: MixerNodeId
  play_id: PlayId
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestPlay".
 */
export interface RequestPlay {
  bit_depth: PlayBitDepth
  looping: boolean
  mixer_id: MixerNodeId
  play_id: PlayId
  sample_rate: SampleRate
  segment: TimeSegment
  start_at: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestRender".
 */
export interface RequestRender {
  mixer_id: MixerNodeId
  object_id: AppMediaObjectId
  render_id: RenderId
  segment: TimeSegment
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestSeek".
 */
export interface RequestSeek {
  looping: boolean
  play_id: PlayId
  segment: TimeSegment
  start_at: number
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "RequestStopPlay".
 */
export interface RequestStopPlay {
  play_id: PlayId
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SetInstances".
 */
export interface SetInstances {
  instances: {
    [k: string]: EngineFixedInstance
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "SetMedia".
 */
export interface SetMedia {
  media: {
    [k: string]: MediaObject
  }
}
/**
 * Task specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskSpec".
 */
export interface TaskSpec {
  /**
   * Connections between nodes
   */
  connections?: {
    [k: string]: NodeConnection
  }
  /**
   * Dynamic instance nodes of the task
   */
  dynamic?: {
    [k: string]: DynamicInstanceNode
  }
  /**
   * Fixed instance nodes of the task
   */
  fixed?: {
    [k: string]: FixedInstanceNode
  }
  /**
   * Mixer nodes of the task
   */
  mixers?: {
    [k: string]: MixerNode
  }
  /**
   * The revision number of the specification (starts at zero, increments for every change)
   */
  revision?: number
  /**
   * Track nodes of the task
   */
  tracks?: {
    [k: string]: TrackNode
  }
}
/**
 * Track node specification
 *
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TrackNode".
 */
export interface TrackNode {
  /**
   * Number of channels
   */
  channels: MediaChannels
  /**
   * Media items present on the track
   */
  media: {
    [k: string]: TrackMedia
  }
}
/**
 * This interface was referenced by `CloudApi`'s JSON-Schema
 * via the `definition` "TaskWithStatus".
 */
export interface TaskWithStatus {
  id: AppTaskId
  play_state: TaskPlayState
  spec: TaskSpec
}
export class Client {
  constructor(private readonly requester: Requester) {}
  /**
   * Set instance I/O mapping
   *
   * The Audio Engine needs to map FixedInstanceNode to I/O on the audio interface it is bound
   * to. For example, an instance may be bound to channels 0 and 1 or to channels 5 and 6 and
   * the Audio Engine needs to know to route the audio correctly.
   *
   * @param body Request body
   */
  async set_instances(body: SetInstances): Promise<Result<InstancesUpdated, EngineError>> {
    return this.requester.request({ path: `/v1/instances`, method: "put", body: body, headers: {} })
  }
  /**
   * Set media presence
   *
   * The Audio Engine needs to map AppMediaObjectId on track items to
   *
   * @param body Request body
   */
  async set_media(body: SetMedia): Promise<Result<MediaUpdated, EngineError>> {
    return this.requester.request({ path: `/v1/media`, method: "put", body: body, headers: {} })
  }
  /**
   * List tasks
   *
   * Return a list of all current tasks and their play status.
   *
   */
  async list(): Promise<Result<TaskWithStatusList, EngineError>> {
    return this.requester.request({ path: `/v1/tasks`, method: "get", headers: {} })
  }
  /**
   * Delete a task
   *
   * Delete an existing task spec. This will interrupt any playback or rendering and will free
   * resources associated with the task (such as instances or locks on media files).
   *
   * @param app_id App id
   * @param task_id Task id
   */
  async delete_task(app_id: AppId, task_id: TaskId): Promise<Result<TaskDeleted, EngineError>> {
    return this.requester.request({ path: `/v1/tasks/${app_id}/${task_id}`, method: "delete", headers: {} })
  }
  /**
   * Modify task spec
   *
   * Apply a modification to an existing spec. Changing the spec even trivially could result in a
   * rendering or playback interruption. The task must exist in order to be modified.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async modify_task_spec(
    app_id: AppId,
    task_id: TaskId,
    body: ModifyTaskSpec
  ): Promise<Result<TaskModified, EngineError>> {
    return this.requester.request({ path: `/v1/tasks/${app_id}/${task_id}`, method: "patch", body: body, headers: {} })
  }
  /**
   * Create or update task spec
   *
   * Create or update a task by providing its spec. Changing the spec even trivially could result
   * in a rendering or playback interruption.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async set_task_spec(app_id: AppId, task_id: TaskId, body: TaskSpec): Promise<Result<TaskReplaced, EngineError>> {
    return this.requester.request({ path: `/v1/tasks/${app_id}/${task_id}`, method: "put", body: body, headers: {} })
  }
  /**
   * Cancel rendering a task
   *
   * Request to stop (cancel) rendering if the task is rendering.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async cancel_render(
    app_id: AppId,
    task_id: TaskId,
    body: RequestCancelRender
  ): Promise<Result<TaskRenderCancelled, EngineError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/cancel`,
      method: "post",
      body: body,
      headers: {},
    })
  }
  /**
   * Start playing a task
   *
   * Start playing a task that is stopped. The request will return when the task has started to play
   * or with an error.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async play(app_id: AppId, task_id: TaskId, body: RequestPlay): Promise<Result<TaskPlaying, EngineError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/play`,
      method: "post",
      body: body,
      headers: {},
    })
  }
  /**
   * Render a task to a new file
   *
   * Start rendering a task. Note that unlike the orchestration or domain API, the audio engine
   * does not care if the media files are present and will happily execute a render even when no
   * files (or instances) are ready. The caller to this API should make sure that any such
   * preconditions are met.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async render(app_id: AppId, task_id: TaskId, body: RequestRender): Promise<Result<TaskRendering, EngineError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/render`,
      method: "post",
      body: body,
      headers: {},
    })
  }
  /**
   * Seek while task is playing
   *
   * If the task is playing, change the playing position.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async seek_task_play(app_id: AppId, task_id: TaskId, body: RequestSeek): Promise<Result<TaskSought, EngineError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/seek`,
      method: "post",
      body: body,
      headers: {},
    })
  }
  /**
   * Stop playing a task
   *
   * Request to stop a track if the task is playing.
   *
   * @param app_id App id
   * @param task_id Task id
   * @param body Request body
   */
  async stop_playing(
    app_id: AppId,
    task_id: TaskId,
    body: RequestStopPlay
  ): Promise<Result<TaskPlayStopped, EngineError>> {
    return this.requester.request({
      path: `/v1/tasks/${app_id}/${task_id}/transport/stop`,
      method: "post",
      body: body,
      headers: {},
    })
  }
}
