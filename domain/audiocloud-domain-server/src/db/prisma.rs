/*
 * Copyright (c) Audio Cloud, 2022. This code is licensed under MIT license (see LICENSE for details)
 */

// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR: &'static str = include_str!("/Users/baadc0de/Development/GitHub/audiocloud/domain/prisma/prisma/schema.prisma");
static DATABASE_STR: &'static str = "sqlite";
use ::prisma_client_rust::migrations::include_dir;
pub static MIGRATIONS_DIR : & :: prisma_client_rust :: migrations :: include_dir :: Dir = & :: prisma_client_rust :: migrations :: include_dir :: include_dir ! ("/Users/baadc0de/Development/GitHub/audiocloud/domain/prisma/prisma/migrations") ;
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(url: &str) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().with_url(url.to_string()).build().await
}
pub mod model {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod spec {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SpecEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Spec(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSpec(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Spec(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("spec").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Spec(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("spec").build()
            }
        }
    }
    pub mod fixed_instance {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::FixedInstanceSome(value)
        }
        pub fn every(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::FixedInstanceEvery(value)
        }
        pub fn none(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::FixedInstanceNone(value)
        }
        pub struct Fetch(pub fixed_instance::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<fixed_instance::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: fixed_instance::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: fixed_instance::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::FixedInstance(fetch.0)
            }
        }
        pub fn fetch(params: Vec<fixed_instance::WhereParam>) -> Fetch {
            Fetch(fixed_instance::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<fixed_instance::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<fixed_instance::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFixedInstance(params)
        }
        pub fn set(params: Vec<fixed_instance::UniqueWhereParam>) -> SetParam {
            SetParam::SetFixedInstance(params)
        }
        pub struct Connect(pub Vec<fixed_instance::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectFixedInstance(value.0)
            }
        }
        pub enum Include {
            Select(fixed_instance::ManyArgs, Vec<fixed_instance::SelectParam>),
            Include(fixed_instance::ManyArgs, Vec<fixed_instance::IncludeParam>),
            Fetch(fixed_instance::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FixedInstance(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("FixedInstance");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = <fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(fixed_instance::ManyArgs, Vec<fixed_instance::SelectParam>),
            Include(fixed_instance::ManyArgs, Vec<fixed_instance::IncludeParam>),
            Fetch(fixed_instance::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FixedInstance(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("FixedInstance");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(id: String, spec: String, _params: Vec<SetParam>) -> (String, String, Vec<SetParam>) {
        (id, spec, _params)
    }
    pub fn create_unchecked(id: String, spec: String, _params: Vec<SetParam>) -> (String, String, Vec<SetParam>) {
        (id, spec, _params)
    }
    #[macro_export]
    macro_rules ! _select_model { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: model :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: model :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: model :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: model :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: model :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: model :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , spec , fixed_instance } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: model :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: model :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: model :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: model :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: model :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: model :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "spec" , "FixedInstance"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: model :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; spec) => { String } ; (@ field_type ; fixed_instance : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < fixed_instance :: Data > } ; (@ field_type ; fixed_instance) => { Vec < crate :: prisma :: fixed_instance :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Model" , available fields are "id, spec, fixed_instance")) } ; (@ field_module ; fixed_instance : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: fixed_instance :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: model :: SelectParam > :: into ($ crate :: prisma :: model :: id :: Select) } ; (@ selection_field_to_selection_param ; spec) => { Into :: < $ crate :: prisma :: model :: SelectParam > :: into ($ crate :: prisma :: model :: spec :: Select) } ; (@ selection_field_to_selection_param ; fixed_instance $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: model :: SelectParam > :: into ($ crate :: prisma :: model :: fixed_instance :: Select :: $ selection_mode ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: fixed_instance :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; fixed_instance $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: model :: SelectParam > :: into ($ crate :: prisma :: model :: fixed_instance :: Select :: Fetch ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: model :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; spec) => { "spec" } ; (@ field_serde_name ; fixed_instance) => { "FixedInstance" } ; }
    pub use _select_model as select;
    pub enum SelectParam {
        Id(id::Select),
        Spec(spec::Select),
        FixedInstance(fixed_instance::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Spec(data) => data.to_selection(),
                Self::FixedInstance(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_model { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: model :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: model :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: model :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: model :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: model :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: model :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: model :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: model :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { fixed_instance } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub spec : String , $ (pub $ field : $ crate :: prisma :: model :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (spec)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; spec) , & self . spec) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , spec } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: model :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: model :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: model :: include ! (@ field_serde_name ; spec) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: model :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: model :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: model :: include ! (@ field_serde_name ; spec) => Ok (Field :: spec) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut spec = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: spec => { if spec . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; spec))) ; } spec = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; id))) ? ; let spec = spec . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: model :: include ! (@ field_serde_name ; spec))) ? ; Ok (Data { id , spec , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "spec" , "FixedInstance"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: model :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; fixed_instance : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < fixed_instance :: Data > } ; (@ field_type ; fixed_instance) => { Vec < crate :: prisma :: fixed_instance :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Model" , available relations are "fixed_instance")) } ; (@ field_module ; fixed_instance : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: fixed_instance :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; fixed_instance $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: model :: IncludeParam > :: into ($ crate :: prisma :: model :: fixed_instance :: Include :: $ selection_mode ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: fixed_instance :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; fixed_instance $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: model :: IncludeParam > :: into ($ crate :: prisma :: model :: fixed_instance :: Include :: Fetch ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: model :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; spec) => { "spec" } ; (@ field_serde_name ; fixed_instance) => { "FixedInstance" } ; }
    pub use _include_model as include;
    pub enum IncludeParam {
        Id(id::Include),
        Spec(spec::Include),
        FixedInstance(fixed_instance::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Spec(data) => data.to_selection(),
                Self::FixedInstance(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id:             String,
        #[serde(rename = "spec")]
        pub spec:           String,
        #[serde(rename = "FixedInstance")]
        pub fixed_instance: Option<Vec<super::fixed_instance::Data>>,
    }
    impl Data {
        pub fn fixed_instance(&self) -> Result<&Vec<super::fixed_instance::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.fixed_instance
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(fixed_instance)))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        FixedInstance(super::fixed_instance::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::FixedInstance(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    let mut builder = ::prisma_client_rust::Selection::builder("FixedInstance");
                    builder.nested_selections(nested_selections).set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetSpec(String),
        ConnectFixedInstance(Vec<super::fixed_instance::UniqueWhereParam>),
        DisconnectFixedInstance(Vec<super::fixed_instance::UniqueWhereParam>),
        SetFixedInstance(Vec<super::fixed_instance::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetSpec (value) => ("spec" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectFixedInstance (where_params) => ("FixedInstance" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectFixedInstance (where_params) => ("FixedInstance" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetFixedInstance (where_params) => ("FixedInstance" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Spec(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Spec(direction) => ("spec".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        Id(_prisma::read_filters::StringFilter),
        SpecEquals(String),
        Spec(_prisma::read_filters::StringFilter),
        FixedInstanceSome(Vec<super::fixed_instance::WhereParam>),
        FixedInstanceEvery(Vec<super::fixed_instance::WhereParam>),
        FixedInstanceNone(Vec<super::fixed_instance::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: SpecEquals (value) => ("spec" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Spec (value) => ("spec" , value . into ()) , Self :: FixedInstanceSome (where_params) => ("FixedInstance" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: FixedInstanceEvery (where_params) => ("FixedInstance" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: FixedInstanceNone (where_params) => ("FixedInstance" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Model";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "spec"].into_iter()
                          .map(|o| {
                              let builder = ::prisma_client_rust::Selection::builder(o);
                              builder.build()
                          })
                          .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, id: String, spec: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(spec::set(spec));
            Create::new(self.client, _params)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(self,
                      _where: UniqueWhereParam,
                      (id, spec, mut _params): (String, String, Vec<SetParam>),
                      _update: Vec<SetParam>)
                      -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(spec::set(spec));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod fixed_instance {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod model_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ModelIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ModelId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ModelId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetModelId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ModelId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("model_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ModelId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("model_id").build()
            }
        }
    }
    pub mod driver_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::DriverIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DriverId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DriverId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDriverId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DriverId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("driver_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DriverId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("driver_id").build()
            }
        }
    }
    pub mod engine_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::EngineIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EngineId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEngineId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EngineId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("engine_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EngineId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("engine_id").build()
            }
        }
    }
    pub mod config {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ConfigEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Config(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetConfig(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Config(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Config(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
    }
    pub mod model {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<model::WhereParam>) -> WhereParam {
            WhereParam::ModelIs(value)
        }
        pub fn is_not(value: Vec<model::WhereParam>) -> WhereParam {
            WhereParam::ModelIsNot(value)
        }
        pub struct Fetch(pub model::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<model::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Model(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(model::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: model::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(model::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectModel(value.0)
            }
        }
        pub enum Include {
            Select(Vec<model::SelectParam>),
            Include(Vec<model::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Model(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("model");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = <model::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(<model::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<model::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<model::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<model::SelectParam>),
            Include(Vec<model::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Model(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("model");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch => {
                        selection.nested_selections(<model::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<model::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<model::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod driver {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<fixed_instance_driver::WhereParam>) -> WhereParam {
            WhereParam::DriverIs(value)
        }
        pub fn is_not(value: Vec<fixed_instance_driver::WhereParam>) -> WhereParam {
            WhereParam::DriverIsNot(value)
        }
        pub struct Fetch(pub fixed_instance_driver::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<fixed_instance_driver::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Driver(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(fixed_instance_driver::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: fixed_instance_driver::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectDriver
        }
        pub struct Connect(fixed_instance_driver::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectDriver(value.0)
            }
        }
        pub enum Include {
            Select(Vec<fixed_instance_driver::SelectParam>),
            Include(Vec<fixed_instance_driver::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Driver(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("driver");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <fixed_instance_driver::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection . nested_selections (< fixed_instance_driver :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<fixed_instance_driver::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<fixed_instance_driver::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<fixed_instance_driver::SelectParam>),
            Include(Vec<fixed_instance_driver::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Driver(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("driver");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch => {
                        selection . nested_selections (< fixed_instance_driver :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections ()) ;
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<fixed_instance_driver::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<fixed_instance_driver::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod engine {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<engine::WhereParam>) -> WhereParam {
            WhereParam::EngineIs(value)
        }
        pub fn is_not(value: Vec<engine::WhereParam>) -> WhereParam {
            WhereParam::EngineIsNot(value)
        }
        pub struct Fetch(pub engine::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<engine::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Engine(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(engine::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: engine::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectEngine
        }
        pub struct Connect(engine::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectEngine(value.0)
            }
        }
        pub enum Include {
            Select(Vec<engine::SelectParam>),
            Include(Vec<engine::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Engine(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("engine");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = <engine::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(<engine::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<engine::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<engine::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<engine::SelectParam>),
            Include(Vec<engine::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Engine(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("engine");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch => {
                        selection.nested_selections(<engine::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<engine::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<engine::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(id: String,
                  config: String,
                  model: super::model::UniqueWhereParam,
                  _params: Vec<SetParam>)
                  -> (String, String, super::model::UniqueWhereParam, Vec<SetParam>) {
        (id, config, model, _params)
    }
    pub fn create_unchecked(id: String,
                            model_id: String,
                            config: String,
                            _params: Vec<SetParam>)
                            -> (String, String, String, Vec<SetParam>) {
        (id, model_id, config, _params)
    }
    #[macro_export]
    macro_rules ! _select_fixed_instance { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: fixed_instance :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: fixed_instance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: fixed_instance :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: fixed_instance :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: fixed_instance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: fixed_instance :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , model_id , driver_id , engine_id , config , model , driver , engine } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: fixed_instance :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: fixed_instance :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: fixed_instance :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: fixed_instance :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "model_id" , "driver_id" , "engine_id" , "config" , "model" , "driver" , "engine"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: fixed_instance :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; model_id) => { String } ; (@ field_type ; driver_id) => { Option < String > } ; (@ field_type ; engine_id) => { Option < String > } ; (@ field_type ; config) => { String } ; (@ field_type ; model : $ selection_mode : ident { $ ($ selections : tt) + }) => { model :: Data } ; (@ field_type ; model) => { crate :: prisma :: model :: Data } ; (@ field_type ; driver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < driver :: Data > } ; (@ field_type ; driver) => { Option < crate :: prisma :: fixed_instance_driver :: Data > } ; (@ field_type ; engine : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < engine :: Data > } ; (@ field_type ; engine) => { Option < crate :: prisma :: engine :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "FixedInstance" , available fields are "id, model_id, driver_id, engine_id, config, model, driver, engine")) } ; (@ field_module ; model : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: model :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; driver : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: fixed_instance_driver :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; engine : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: engine :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: id :: Select) } ; (@ selection_field_to_selection_param ; model_id) => { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: model_id :: Select) } ; (@ selection_field_to_selection_param ; driver_id) => { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: driver_id :: Select) } ; (@ selection_field_to_selection_param ; engine_id) => { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: engine_id :: Select) } ; (@ selection_field_to_selection_param ; config) => { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: config :: Select) } ; (@ selection_field_to_selection_param ; model $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: model :: Select :: $ selection_mode ($ crate :: prisma :: model :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; model $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: model :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; driver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: driver :: Select :: $ selection_mode ($ crate :: prisma :: fixed_instance_driver :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; driver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: driver :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; engine $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: engine :: Select :: $ selection_mode ($ crate :: prisma :: engine :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; engine $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: fixed_instance :: SelectParam > :: into ($ crate :: prisma :: fixed_instance :: engine :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: fixed_instance :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; model_id) => { "model_id" } ; (@ field_serde_name ; driver_id) => { "driver_id" } ; (@ field_serde_name ; engine_id) => { "engine_id" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; model) => { "model" } ; (@ field_serde_name ; driver) => { "driver" } ; (@ field_serde_name ; engine) => { "engine" } ; }
    pub use _select_fixed_instance as select;
    pub enum SelectParam {
        Id(id::Select),
        ModelId(model_id::Select),
        DriverId(driver_id::Select),
        EngineId(engine_id::Select),
        Config(config::Select),
        Model(model::Select),
        Driver(driver::Select),
        Engine(engine::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ModelId(data) => data.to_selection(),
                Self::DriverId(data) => data.to_selection(),
                Self::EngineId(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::Model(data) => data.to_selection(),
                Self::Driver(data) => data.to_selection(),
                Self::Engine(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_fixed_instance { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: fixed_instance :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: fixed_instance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: fixed_instance :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: fixed_instance :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: fixed_instance :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: fixed_instance :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: fixed_instance :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: fixed_instance :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { model , driver , engine } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub model_id : String , pub driver_id : Option < String > , pub engine_id : Option < String > , pub config : String , $ (pub $ field : $ crate :: prisma :: fixed_instance :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (model_id) , stringify ! (driver_id) , stringify ! (engine_id) , stringify ! (config)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; model_id) , & self . model_id) ? ; state . serialize_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; driver_id) , & self . driver_id) ? ; state . serialize_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; engine_id) , & self . engine_id) ? ; state . serialize_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; config) , & self . config) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , model_id , driver_id , engine_id , config } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; model_id) , ", " , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; driver_id) , ", " , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; engine_id) , ", " , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; config) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; model_id) => Ok (Field :: model_id) , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; driver_id) => Ok (Field :: driver_id) , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; engine_id) => Ok (Field :: engine_id) , $ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; config) => Ok (Field :: config) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut model_id = None ; let mut driver_id = None ; let mut engine_id = None ; let mut config = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: model_id => { if model_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; model_id))) ; } model_id = Some (map . next_value () ?) ; } Field :: driver_id => { if driver_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; driver_id))) ; } driver_id = Some (map . next_value () ?) ; } Field :: engine_id => { if engine_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; engine_id))) ; } engine_id = Some (map . next_value () ?) ; } Field :: config => { if config . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; config))) ; } config = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; id))) ? ; let model_id = model_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; model_id))) ? ; let driver_id = driver_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; driver_id))) ? ; let engine_id = engine_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; engine_id))) ? ; let config = config . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance :: include ! (@ field_serde_name ; config))) ? ; Ok (Data { id , model_id , driver_id , engine_id , config , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "model_id" , "driver_id" , "engine_id" , "config" , "model" , "driver" , "engine"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: fixed_instance :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; model : $ selection_mode : ident { $ ($ selections : tt) + }) => { model :: Data } ; (@ field_type ; model) => { crate :: prisma :: model :: Data } ; (@ field_type ; driver : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < driver :: Data > } ; (@ field_type ; driver) => { Option < crate :: prisma :: fixed_instance_driver :: Data > } ; (@ field_type ; engine : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < engine :: Data > } ; (@ field_type ; engine) => { Option < crate :: prisma :: engine :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FixedInstance" , available relations are "model, driver, engine")) } ; (@ field_module ; model : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: model :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; driver : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: fixed_instance_driver :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; engine : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: engine :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; model $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: fixed_instance :: IncludeParam > :: into ($ crate :: prisma :: fixed_instance :: model :: Include :: $ selection_mode ($ crate :: prisma :: model :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; model $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: fixed_instance :: IncludeParam > :: into ($ crate :: prisma :: fixed_instance :: model :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; driver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: fixed_instance :: IncludeParam > :: into ($ crate :: prisma :: fixed_instance :: driver :: Include :: $ selection_mode ($ crate :: prisma :: fixed_instance_driver :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; driver $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: fixed_instance :: IncludeParam > :: into ($ crate :: prisma :: fixed_instance :: driver :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; engine $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: fixed_instance :: IncludeParam > :: into ($ crate :: prisma :: fixed_instance :: engine :: Include :: $ selection_mode ($ crate :: prisma :: engine :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; engine $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: fixed_instance :: IncludeParam > :: into ($ crate :: prisma :: fixed_instance :: engine :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: fixed_instance :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; model_id) => { "model_id" } ; (@ field_serde_name ; driver_id) => { "driver_id" } ; (@ field_serde_name ; engine_id) => { "engine_id" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; model) => { "model" } ; (@ field_serde_name ; driver) => { "driver" } ; (@ field_serde_name ; engine) => { "engine" } ; }
    pub use _include_fixed_instance as include;
    pub enum IncludeParam {
        Id(id::Include),
        ModelId(model_id::Include),
        DriverId(driver_id::Include),
        EngineId(engine_id::Include),
        Config(config::Include),
        Model(model::Include),
        Driver(driver::Include),
        Engine(engine::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::ModelId(data) => data.to_selection(),
                Self::DriverId(data) => data.to_selection(),
                Self::EngineId(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::Model(data) => data.to_selection(),
                Self::Driver(data) => data.to_selection(),
                Self::Engine(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id:        String,
        #[serde(rename = "model_id")]
        pub model_id:  String,
        #[serde(rename = "driver_id")]
        pub driver_id: Option<String>,
        #[serde(rename = "engine_id")]
        pub engine_id: Option<String>,
        #[serde(rename = "config")]
        pub config:    String,
        #[serde(rename = "model")]
        pub model:     Option<Box<super::model::Data>>,
        #[serde(rename = "driver",
                default,
                skip_serializing_if = "Option::is_none",
                with = "prisma_client_rust::serde::double_option")]
        pub driver:    Option<Option<Box<super::fixed_instance_driver::Data>>>,
        #[serde(rename = "engine",
                default,
                skip_serializing_if = "Option::is_none",
                with = "prisma_client_rust::serde::double_option")]
        pub engine:    Option<Option<Box<super::engine::Data>>>,
    }
    impl Data {
        pub fn model(&self) -> Result<&super::model::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.model
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(model)))
                .map(|v| v.as_ref())
        }
        pub fn driver(&self) -> Result<Option<&super::fixed_instance_driver::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.driver
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(driver)))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn engine(&self) -> Result<Option<&super::engine::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.engine
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(engine)))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Model(super::model::UniqueArgs),
        Driver(super::fixed_instance_driver::UniqueArgs),
        Engine(super::engine::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Model(args) => {
                    let mut selections = <super::model::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                    selections.extend(args.with_params.into_iter().map(Into::<::prisma_client_rust::Selection>::into));
                    let mut builder = ::prisma_client_rust::Selection::builder("model");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Driver(args) => {
                    let mut selections = <super::fixed_instance_driver::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                    selections.extend(args.with_params.into_iter().map(Into::<::prisma_client_rust::Selection>::into));
                    let mut builder = ::prisma_client_rust::Selection::builder("driver");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::Engine(args) => {
                    let mut selections = <super::engine::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                    selections.extend(args.with_params.into_iter().map(Into::<::prisma_client_rust::Selection>::into));
                    let mut builder = ::prisma_client_rust::Selection::builder("engine");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetModelId(String),
        SetDriverId(Option<String>),
        SetEngineId(Option<String>),
        SetConfig(String),
        ConnectModel(super::model::UniqueWhereParam),
        ConnectDriver(super::fixed_instance_driver::UniqueWhereParam),
        DisconnectDriver,
        ConnectEngine(super::engine::UniqueWhereParam),
        DisconnectEngine,
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetModelId (value) => ("model_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetDriverId (value) => ("driver_id" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetEngineId (value) => ("engine_id" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetConfig (value) => ("config" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectModel (where_param) => ("model" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: model :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: ConnectDriver (where_param) => ("driver" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: fixed_instance_driver :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: DisconnectDriver => ("driver" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) , SetParam :: ConnectEngine (where_param) => ("engine" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: engine :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: DisconnectEngine => ("engine" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        ModelId(::prisma_client_rust::Direction),
        DriverId(::prisma_client_rust::Direction),
        EngineId(::prisma_client_rust::Direction),
        Config(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::ModelId(direction) => ("model_id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::DriverId(direction) => ("driver_id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::EngineId(direction) => ("engine_id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Config(direction) => ("config".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        Id(_prisma::read_filters::StringFilter),
        ModelIdEquals(String),
        ModelId(_prisma::read_filters::StringFilter),
        DriverIdEquals(Option<String>),
        DriverId(_prisma::read_filters::StringFilter),
        EngineIdEquals(Option<String>),
        EngineId(_prisma::read_filters::StringFilter),
        ConfigEquals(String),
        Config(_prisma::read_filters::StringFilter),
        ModelIs(Vec<super::model::WhereParam>),
        ModelIsNot(Vec<super::model::WhereParam>),
        DriverIs(Vec<super::fixed_instance_driver::WhereParam>),
        DriverIsNot(Vec<super::fixed_instance_driver::WhereParam>),
        EngineIs(Vec<super::engine::WhereParam>),
        EngineIsNot(Vec<super::engine::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: ModelIdEquals (value) => ("model_id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: ModelId (value) => ("model_id" , value . into ()) , Self :: DriverIdEquals (value) => ("driver_id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: DriverId (value) => ("driver_id" , value . into ()) , Self :: EngineIdEquals (value) => ("engine_id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: EngineId (value) => ("engine_id" , value . into ()) , Self :: ConfigEquals (value) => ("config" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Config (value) => ("config" , value . into ()) , Self :: ModelIs (where_params) => ("model" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ModelIsNot (where_params) => ("model" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: DriverIs (where_params) => ("driver" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: DriverIsNot (where_params) => ("driver" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: EngineIs (where_params) => ("engine" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: EngineIsNot (where_params) => ("engine" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "FixedInstance";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "model_id", "driver_id", "engine_id", "config"].into_iter()
                                                                  .map(|o| {
                                                                      let builder = ::prisma_client_rust::Selection::builder(o);
                                                                      builder.build()
                                                                  })
                                                                  .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, id: String, config: String, model: super::model::UniqueWhereParam, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(config::set(config));
            _params.push(model::connect(model));
            Create::new(self.client, _params)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(self,
                      _where: UniqueWhereParam,
                      (id, config, model, mut _params): (String, String, super::model::UniqueWhereParam, Vec<SetParam>),
                      _update: Vec<SetParam>)
                      -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(config::set(config));
            _params.push(model::connect(model));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod fixed_instance_driver {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod url {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UrlEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Url(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUrl(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Url(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("url").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Url(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("url").build()
            }
        }
    }
    pub mod last_seen {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastSeenEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastSeen(direction)
        }
        pub fn in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(pub Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLastSeen(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastSeen(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("last_seen").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastSeen(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("last_seen").build()
            }
        }
    }
    pub mod config {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ConfigEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Config(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetConfig(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Config(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Config(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
    }
    pub mod instances {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::InstancesSome(value)
        }
        pub fn every(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::InstancesEvery(value)
        }
        pub fn none(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::InstancesNone(value)
        }
        pub struct Fetch(pub fixed_instance::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<fixed_instance::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: fixed_instance::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: fixed_instance::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Instances(fetch.0)
            }
        }
        pub fn fetch(params: Vec<fixed_instance::WhereParam>) -> Fetch {
            Fetch(fixed_instance::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<fixed_instance::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<fixed_instance::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectInstances(params)
        }
        pub fn set(params: Vec<fixed_instance::UniqueWhereParam>) -> SetParam {
            SetParam::SetInstances(params)
        }
        pub struct Connect(pub Vec<fixed_instance::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectInstances(value.0)
            }
        }
        pub enum Include {
            Select(fixed_instance::ManyArgs, Vec<fixed_instance::SelectParam>),
            Include(fixed_instance::ManyArgs, Vec<fixed_instance::IncludeParam>),
            Fetch(fixed_instance::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Instances(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("instances");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = <fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(fixed_instance::ManyArgs, Vec<fixed_instance::SelectParam>),
            Include(fixed_instance::ManyArgs, Vec<fixed_instance::IncludeParam>),
            Fetch(fixed_instance::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Instances(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("instances");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(id: String, url: String, config: String, _params: Vec<SetParam>) -> (String, String, String, Vec<SetParam>) {
        (id, url, config, _params)
    }
    pub fn create_unchecked(id: String, url: String, config: String, _params: Vec<SetParam>) -> (String, String, String, Vec<SetParam>) {
        (id, url, config, _params)
    }
    #[macro_export]
    macro_rules ! _select_fixed_instance_driver { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: fixed_instance_driver :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: fixed_instance_driver :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: fixed_instance_driver :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: fixed_instance_driver :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: fixed_instance_driver :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: fixed_instance_driver :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , url , last_seen , config , instances } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: fixed_instance_driver :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: fixed_instance_driver :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: fixed_instance_driver :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: fixed_instance_driver :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance_driver :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance_driver :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "last_seen" , "config" , "instances"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: fixed_instance_driver :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; url) => { String } ; (@ field_type ; last_seen) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; config) => { String } ; (@ field_type ; instances : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < instances :: Data > } ; (@ field_type ; instances) => { Vec < crate :: prisma :: fixed_instance :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "FixedInstanceDriver" , available fields are "id, url, last_seen, config, instances")) } ; (@ field_module ; instances : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: fixed_instance :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: fixed_instance_driver :: SelectParam > :: into ($ crate :: prisma :: fixed_instance_driver :: id :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: fixed_instance_driver :: SelectParam > :: into ($ crate :: prisma :: fixed_instance_driver :: url :: Select) } ; (@ selection_field_to_selection_param ; last_seen) => { Into :: < $ crate :: prisma :: fixed_instance_driver :: SelectParam > :: into ($ crate :: prisma :: fixed_instance_driver :: last_seen :: Select) } ; (@ selection_field_to_selection_param ; config) => { Into :: < $ crate :: prisma :: fixed_instance_driver :: SelectParam > :: into ($ crate :: prisma :: fixed_instance_driver :: config :: Select) } ; (@ selection_field_to_selection_param ; instances $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: fixed_instance_driver :: SelectParam > :: into ($ crate :: prisma :: fixed_instance_driver :: instances :: Select :: $ selection_mode ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: fixed_instance :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; instances $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: fixed_instance_driver :: SelectParam > :: into ($ crate :: prisma :: fixed_instance_driver :: instances :: Select :: Fetch ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: fixed_instance_driver :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; last_seen) => { "last_seen" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; instances) => { "instances" } ; }
    pub use _select_fixed_instance_driver as select;
    pub enum SelectParam {
        Id(id::Select),
        Url(url::Select),
        LastSeen(last_seen::Select),
        Config(config::Select),
        Instances(instances::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::LastSeen(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::Instances(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_fixed_instance_driver { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: fixed_instance_driver :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: fixed_instance_driver :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: fixed_instance_driver :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: fixed_instance_driver :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: fixed_instance_driver :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: fixed_instance_driver :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: fixed_instance_driver :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: fixed_instance_driver :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { instances } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub url : String , pub last_seen : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub config : String , $ (pub $ field : $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (url) , stringify ! (last_seen) , stringify ! (config)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; last_seen) , & self . last_seen) ? ; state . serialize_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; config) , & self . config) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , url , last_seen , config } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; last_seen) , ", " , $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; config) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; last_seen) => Ok (Field :: last_seen) , $ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; config) => Ok (Field :: config) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut url = None ; let mut last_seen = None ; let mut config = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: last_seen => { if last_seen . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; last_seen))) ; } last_seen = Some (map . next_value () ?) ; } Field :: config => { if config . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; config))) ; } config = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; id))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; url))) ? ; let last_seen = last_seen . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; last_seen))) ? ; let config = config . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: fixed_instance_driver :: include ! (@ field_serde_name ; config))) ? ; Ok (Data { id , url , last_seen , config , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "last_seen" , "config" , "instances"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: fixed_instance_driver :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; instances : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < instances :: Data > } ; (@ field_type ; instances) => { Vec < crate :: prisma :: fixed_instance :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FixedInstanceDriver" , available relations are "instances")) } ; (@ field_module ; instances : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: fixed_instance :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; instances $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: fixed_instance_driver :: IncludeParam > :: into ($ crate :: prisma :: fixed_instance_driver :: instances :: Include :: $ selection_mode ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: fixed_instance :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; instances $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: fixed_instance_driver :: IncludeParam > :: into ($ crate :: prisma :: fixed_instance_driver :: instances :: Include :: Fetch ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: fixed_instance_driver :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; last_seen) => { "last_seen" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; instances) => { "instances" } ; }
    pub use _include_fixed_instance_driver as include;
    pub enum IncludeParam {
        Id(id::Include),
        Url(url::Include),
        LastSeen(last_seen::Include),
        Config(config::Include),
        Instances(instances::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::LastSeen(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::Instances(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id:        String,
        #[serde(rename = "url")]
        pub url:       String,
        #[serde(rename = "last_seen")]
        pub last_seen: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        #[serde(rename = "config")]
        pub config:    String,
        #[serde(rename = "instances")]
        pub instances: Option<Vec<super::fixed_instance::Data>>,
    }
    impl Data {
        pub fn instances(&self) -> Result<&Vec<super::fixed_instance::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.instances
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(instances)))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Instances(super::fixed_instance::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Instances(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    let mut builder = ::prisma_client_rust::Selection::builder("instances");
                    builder.nested_selections(nested_selections).set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUrl(String),
        SetLastSeen(Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
        SetConfig(String),
        ConnectInstances(Vec<super::fixed_instance::UniqueWhereParam>),
        DisconnectInstances(Vec<super::fixed_instance::UniqueWhereParam>),
        SetInstances(Vec<super::fixed_instance::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetUrl (value) => ("url" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetLastSeen (value) => ("last_seen" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetConfig (value) => ("config" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectInstances (where_params) => ("instances" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectInstances (where_params) => ("instances" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetInstances (where_params) => ("instances" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Url(::prisma_client_rust::Direction),
        LastSeen(::prisma_client_rust::Direction),
        Config(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Url(direction) => ("url".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::LastSeen(direction) => ("last_seen".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Config(direction) => ("config".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        Id(_prisma::read_filters::StringFilter),
        UrlEquals(String),
        Url(_prisma::read_filters::StringFilter),
        LastSeenEquals(Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
        LastSeen(_prisma::read_filters::DateTimeFilter),
        ConfigEquals(String),
        Config(_prisma::read_filters::StringFilter),
        InstancesSome(Vec<super::fixed_instance::WhereParam>),
        InstancesEvery(Vec<super::fixed_instance::WhereParam>),
        InstancesNone(Vec<super::fixed_instance::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: UrlEquals (value) => ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Url (value) => ("url" , value . into ()) , Self :: LastSeenEquals (value) => ("last_seen" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: LastSeen (value) => ("last_seen" , value . into ()) , Self :: ConfigEquals (value) => ("config" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Config (value) => ("config" , value . into ()) , Self :: InstancesSome (where_params) => ("instances" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: InstancesEvery (where_params) => ("instances" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: InstancesNone (where_params) => ("instances" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "FixedInstanceDriver";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "url", "last_seen", "config"].into_iter()
                                                .map(|o| {
                                                    let builder = ::prisma_client_rust::Selection::builder(o);
                                                    builder.build()
                                                })
                                                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, id: String, url: String, config: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(url::set(url));
            _params.push(config::set(config));
            Create::new(self.client, _params)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(self,
                      _where: UniqueWhereParam,
                      (id, url, config, mut _params): (String, String, String, Vec<SetParam>),
                      _update: Vec<SetParam>)
                      -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(url::set(url));
            _params.push(config::set(config));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod engine {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod url {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::UrlEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Url(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUrl(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Url(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("url").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Url(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("url").build()
            }
        }
    }
    pub mod last_seen {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastSeenEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastSeen(direction)
        }
        pub fn in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastSeen(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(pub Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLastSeen(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastSeen(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("last_seen").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastSeen(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("last_seen").build()
            }
        }
    }
    pub mod config {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ConfigEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Config(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetConfig(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Config(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Config(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
    }
    pub mod instances {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::InstancesSome(value)
        }
        pub fn every(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::InstancesEvery(value)
        }
        pub fn none(value: Vec<fixed_instance::WhereParam>) -> WhereParam {
            WhereParam::InstancesNone(value)
        }
        pub struct Fetch(pub fixed_instance::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<fixed_instance::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: fixed_instance::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: fixed_instance::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Instances(fetch.0)
            }
        }
        pub fn fetch(params: Vec<fixed_instance::WhereParam>) -> Fetch {
            Fetch(fixed_instance::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<fixed_instance::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<fixed_instance::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectInstances(params)
        }
        pub fn set(params: Vec<fixed_instance::UniqueWhereParam>) -> SetParam {
            SetParam::SetInstances(params)
        }
        pub struct Connect(pub Vec<fixed_instance::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectInstances(value.0)
            }
        }
        pub enum Include {
            Select(fixed_instance::ManyArgs, Vec<fixed_instance::SelectParam>),
            Include(fixed_instance::ManyArgs, Vec<fixed_instance::IncludeParam>),
            Fetch(fixed_instance::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Instances(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("instances");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = <fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(fixed_instance::ManyArgs, Vec<fixed_instance::SelectParam>),
            Include(fixed_instance::ManyArgs, Vec<fixed_instance::IncludeParam>),
            Fetch(fixed_instance::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Instances(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("instances");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: fixed_instance::ManyArgs, nested_selections: Vec<fixed_instance::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod tasks {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::TasksSome(value)
        }
        pub fn every(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::TasksEvery(value)
        }
        pub fn none(value: Vec<task::WhereParam>) -> WhereParam {
            WhereParam::TasksNone(value)
        }
        pub struct Fetch(pub task::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<task::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: task::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: task::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Tasks(fetch.0)
            }
        }
        pub fn fetch(params: Vec<task::WhereParam>) -> Fetch {
            Fetch(task::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<task::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<task::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectTasks(params)
        }
        pub fn set(params: Vec<task::UniqueWhereParam>) -> SetParam {
            SetParam::SetTasks(params)
        }
        pub struct Connect(pub Vec<task::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectTasks(value.0)
            }
        }
        pub enum Include {
            Select(task::ManyArgs, Vec<task::SelectParam>),
            Include(task::ManyArgs, Vec<task::IncludeParam>),
            Fetch(task::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Tasks(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("tasks");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = <task::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<task::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: task::ManyArgs, nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: task::ManyArgs, nested_selections: Vec<task::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(task::ManyArgs, Vec<task::SelectParam>),
            Include(task::ManyArgs, Vec<task::IncludeParam>),
            Fetch(task::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Tasks(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("tasks");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<task::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: task::ManyArgs, nested_selections: Vec<task::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: task::ManyArgs, nested_selections: Vec<task::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(id: String, url: String, config: String, _params: Vec<SetParam>) -> (String, String, String, Vec<SetParam>) {
        (id, url, config, _params)
    }
    pub fn create_unchecked(id: String, url: String, config: String, _params: Vec<SetParam>) -> (String, String, String, Vec<SetParam>) {
        (id, url, config, _params)
    }
    #[macro_export]
    macro_rules ! _select_engine { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: engine :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: engine :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: engine :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: engine :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: engine :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: engine :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , url , last_seen , config , instances , tasks } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: engine :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: engine :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: engine :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: engine :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: engine :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: engine :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "last_seen" , "config" , "instances" , "tasks"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: engine :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; url) => { String } ; (@ field_type ; last_seen) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; config) => { String } ; (@ field_type ; instances : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < instances :: Data > } ; (@ field_type ; instances) => { Vec < crate :: prisma :: fixed_instance :: Data > } ; (@ field_type ; tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tasks :: Data > } ; (@ field_type ; tasks) => { Vec < crate :: prisma :: task :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Engine" , available fields are "id, url, last_seen, config, instances, tasks")) } ; (@ field_module ; instances : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: fixed_instance :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: task :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: engine :: SelectParam > :: into ($ crate :: prisma :: engine :: id :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < $ crate :: prisma :: engine :: SelectParam > :: into ($ crate :: prisma :: engine :: url :: Select) } ; (@ selection_field_to_selection_param ; last_seen) => { Into :: < $ crate :: prisma :: engine :: SelectParam > :: into ($ crate :: prisma :: engine :: last_seen :: Select) } ; (@ selection_field_to_selection_param ; config) => { Into :: < $ crate :: prisma :: engine :: SelectParam > :: into ($ crate :: prisma :: engine :: config :: Select) } ; (@ selection_field_to_selection_param ; instances $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: engine :: SelectParam > :: into ($ crate :: prisma :: engine :: instances :: Select :: $ selection_mode ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: fixed_instance :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; instances $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: engine :: SelectParam > :: into ($ crate :: prisma :: engine :: instances :: Select :: Fetch ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: engine :: SelectParam > :: into ($ crate :: prisma :: engine :: tasks :: Select :: $ selection_mode ($ crate :: prisma :: task :: ManyArgs :: new ($ crate :: prisma :: task :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: task :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: engine :: SelectParam > :: into ($ crate :: prisma :: engine :: tasks :: Select :: Fetch ($ crate :: prisma :: task :: ManyArgs :: new ($ crate :: prisma :: task :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: engine :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; last_seen) => { "last_seen" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; instances) => { "instances" } ; (@ field_serde_name ; tasks) => { "tasks" } ; }
    pub use _select_engine as select;
    pub enum SelectParam {
        Id(id::Select),
        Url(url::Select),
        LastSeen(last_seen::Select),
        Config(config::Select),
        Instances(instances::Select),
        Tasks(tasks::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::LastSeen(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::Instances(data) => data.to_selection(),
                Self::Tasks(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_engine { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: engine :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: engine :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: engine :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: engine :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: engine :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: engine :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: engine :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: engine :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { instances , tasks } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub url : String , pub last_seen : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub config : String , $ (pub $ field : $ crate :: prisma :: engine :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (url) , stringify ! (last_seen) , stringify ! (config)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; url) , & self . url) ? ; state . serialize_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; last_seen) , & self . last_seen) ? ; state . serialize_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; config) , & self . config) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , url , last_seen , config } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: engine :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: engine :: include ! (@ field_serde_name ; url) , ", " , $ crate :: prisma :: engine :: include ! (@ field_serde_name ; last_seen) , ", " , $ crate :: prisma :: engine :: include ! (@ field_serde_name ; config) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: engine :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: engine :: include ! (@ field_serde_name ; url) => Ok (Field :: url) , $ crate :: prisma :: engine :: include ! (@ field_serde_name ; last_seen) => Ok (Field :: last_seen) , $ crate :: prisma :: engine :: include ! (@ field_serde_name ; config) => Ok (Field :: config) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut url = None ; let mut last_seen = None ; let mut config = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; url))) ; } url = Some (map . next_value () ?) ; } Field :: last_seen => { if last_seen . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; last_seen))) ; } last_seen = Some (map . next_value () ?) ; } Field :: config => { if config . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; config))) ; } config = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; id))) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; url))) ? ; let last_seen = last_seen . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; last_seen))) ? ; let config = config . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: engine :: include ! (@ field_serde_name ; config))) ? ; Ok (Data { id , url , last_seen , config , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "url" , "last_seen" , "config" , "instances" , "tasks"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: engine :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; instances : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < instances :: Data > } ; (@ field_type ; instances) => { Vec < crate :: prisma :: fixed_instance :: Data > } ; (@ field_type ; tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < tasks :: Data > } ; (@ field_type ; tasks) => { Vec < crate :: prisma :: task :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Engine" , available relations are "instances, tasks")) } ; (@ field_module ; instances : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: fixed_instance :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; tasks : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: task :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; instances $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: engine :: IncludeParam > :: into ($ crate :: prisma :: engine :: instances :: Include :: $ selection_mode ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: fixed_instance :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; instances $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: engine :: IncludeParam > :: into ($ crate :: prisma :: engine :: instances :: Include :: Fetch ($ crate :: prisma :: fixed_instance :: ManyArgs :: new ($ crate :: prisma :: fixed_instance :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: engine :: IncludeParam > :: into ($ crate :: prisma :: engine :: tasks :: Include :: $ selection_mode ($ crate :: prisma :: task :: ManyArgs :: new ($ crate :: prisma :: task :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: task :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; tasks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: engine :: IncludeParam > :: into ($ crate :: prisma :: engine :: tasks :: Include :: Fetch ($ crate :: prisma :: task :: ManyArgs :: new ($ crate :: prisma :: task :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: engine :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; last_seen) => { "last_seen" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; instances) => { "instances" } ; (@ field_serde_name ; tasks) => { "tasks" } ; }
    pub use _include_engine as include;
    pub enum IncludeParam {
        Id(id::Include),
        Url(url::Include),
        LastSeen(last_seen::Include),
        Config(config::Include),
        Instances(instances::Include),
        Tasks(tasks::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::LastSeen(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::Instances(data) => data.to_selection(),
                Self::Tasks(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id:        String,
        #[serde(rename = "url")]
        pub url:       String,
        #[serde(rename = "last_seen")]
        pub last_seen: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        #[serde(rename = "config")]
        pub config:    String,
        #[serde(rename = "instances")]
        pub instances: Option<Vec<super::fixed_instance::Data>>,
        #[serde(rename = "tasks")]
        pub tasks:     Option<Vec<super::task::Data>>,
    }
    impl Data {
        pub fn instances(&self) -> Result<&Vec<super::fixed_instance::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.instances
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(instances)))
        }
        pub fn tasks(&self) -> Result<&Vec<super::task::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.tasks
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(tasks)))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Instances(super::fixed_instance::ManyArgs),
        Tasks(super::task::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Instances(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::fixed_instance::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    let mut builder = ::prisma_client_rust::Selection::builder("instances");
                    builder.nested_selections(nested_selections).set_arguments(arguments);
                    builder.build()
                }
                Self::Tasks(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::task::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    let mut builder = ::prisma_client_rust::Selection::builder("tasks");
                    builder.nested_selections(nested_selections).set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetUrl(String),
        SetLastSeen(Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
        SetConfig(String),
        ConnectInstances(Vec<super::fixed_instance::UniqueWhereParam>),
        DisconnectInstances(Vec<super::fixed_instance::UniqueWhereParam>),
        SetInstances(Vec<super::fixed_instance::UniqueWhereParam>),
        ConnectTasks(Vec<super::task::UniqueWhereParam>),
        DisconnectTasks(Vec<super::task::UniqueWhereParam>),
        SetTasks(Vec<super::task::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetUrl (value) => ("url" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetLastSeen (value) => ("last_seen" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetConfig (value) => ("config" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectInstances (where_params) => ("instances" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectInstances (where_params) => ("instances" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetInstances (where_params) => ("instances" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: fixed_instance :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: ConnectTasks (where_params) => ("tasks" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: task :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectTasks (where_params) => ("tasks" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: task :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetTasks (where_params) => ("tasks" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: task :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Url(::prisma_client_rust::Direction),
        LastSeen(::prisma_client_rust::Direction),
        Config(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Url(direction) => ("url".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::LastSeen(direction) => ("last_seen".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Config(direction) => ("config".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        Id(_prisma::read_filters::StringFilter),
        UrlEquals(String),
        Url(_prisma::read_filters::StringFilter),
        LastSeenEquals(Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
        LastSeen(_prisma::read_filters::DateTimeFilter),
        ConfigEquals(String),
        Config(_prisma::read_filters::StringFilter),
        InstancesSome(Vec<super::fixed_instance::WhereParam>),
        InstancesEvery(Vec<super::fixed_instance::WhereParam>),
        InstancesNone(Vec<super::fixed_instance::WhereParam>),
        TasksSome(Vec<super::task::WhereParam>),
        TasksEvery(Vec<super::task::WhereParam>),
        TasksNone(Vec<super::task::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: UrlEquals (value) => ("url" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Url (value) => ("url" , value . into ()) , Self :: LastSeenEquals (value) => ("last_seen" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: LastSeen (value) => ("last_seen" , value . into ()) , Self :: ConfigEquals (value) => ("config" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Config (value) => ("config" , value . into ()) , Self :: InstancesSome (where_params) => ("instances" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: InstancesEvery (where_params) => ("instances" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: InstancesNone (where_params) => ("instances" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TasksSome (where_params) => ("tasks" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TasksEvery (where_params) => ("tasks" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: TasksNone (where_params) => ("tasks" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Engine";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "url", "last_seen", "config"].into_iter()
                                                .map(|o| {
                                                    let builder = ::prisma_client_rust::Selection::builder(o);
                                                    builder.build()
                                                })
                                                .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, id: String, url: String, config: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(url::set(url));
            _params.push(config::set(config));
            Create::new(self.client, _params)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(self,
                      _where: UniqueWhereParam,
                      (id, url, config, mut _params): (String, String, String, Vec<SetParam>),
                      _update: Vec<SetParam>)
                      -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(url::set(url));
            _params.push(config::set(config));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod media_file {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod path {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::PathEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Path(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPath(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Path(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("path").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Path(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("path").build()
            }
        }
    }
    pub mod metadata {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::MetadataEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Metadata(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMetadata(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Metadata(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("metadata").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Metadata(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("metadata").build()
            }
        }
    }
    pub mod last_used {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastUsedEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastUsed(direction)
        }
        pub fn in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastUsed(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::LastUsed(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastUsed(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastUsed(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastUsed(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastUsed(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::LastUsed(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(pub Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLastUsed(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastUsed(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("last_used").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastUsed(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("last_used").build()
            }
        }
    }
    pub mod revision {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i64) -> T {
            Set(value).into()
        }
        pub fn equals(value: i64) -> WhereParam {
            WhereParam::RevisionEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Revision(direction)
        }
        pub fn in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::BigIntFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<i64>) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::BigIntFilter::NotInVec(value))
        }
        pub fn lt(value: i64) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::BigIntFilter::Lt(value))
        }
        pub fn lte(value: i64) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::BigIntFilter::Lte(value))
        }
        pub fn gt(value: i64) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::BigIntFilter::Gt(value))
        }
        pub fn gte(value: i64) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::BigIntFilter::Gte(value))
        }
        pub fn not(value: i64) -> WhereParam {
            WhereParam::Revision(_prisma::read_filters::BigIntFilter::Not(value))
        }
        pub fn increment(value: i64) -> SetParam {
            SetParam::IncrementRevision(value)
        }
        pub fn decrement(value: i64) -> SetParam {
            SetParam::DecrementRevision(value)
        }
        pub fn multiply(value: i64) -> SetParam {
            SetParam::MultiplyRevision(value)
        }
        pub fn divide(value: i64) -> SetParam {
            SetParam::DivideRevision(value)
        }
        pub struct Set(pub i64);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRevision(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Revision(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("revision").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Revision(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("revision").build()
            }
        }
    }
    pub mod jobs {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<media_job::WhereParam>) -> WhereParam {
            WhereParam::JobsSome(value)
        }
        pub fn every(value: Vec<media_job::WhereParam>) -> WhereParam {
            WhereParam::JobsEvery(value)
        }
        pub fn none(value: Vec<media_job::WhereParam>) -> WhereParam {
            WhereParam::JobsNone(value)
        }
        pub struct Fetch(pub media_job::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<media_job::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: media_job::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: media_job::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Jobs(fetch.0)
            }
        }
        pub fn fetch(params: Vec<media_job::WhereParam>) -> Fetch {
            Fetch(media_job::ManyArgs::new(params))
        }
        pub fn connect<T: From<Connect>>(params: Vec<media_job::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<media_job::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectJobs(params)
        }
        pub fn set(params: Vec<media_job::UniqueWhereParam>) -> SetParam {
            SetParam::SetJobs(params)
        }
        pub struct Connect(pub Vec<media_job::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectJobs(value.0)
            }
        }
        pub enum Include {
            Select(media_job::ManyArgs, Vec<media_job::SelectParam>),
            Include(media_job::ManyArgs, Vec<media_job::IncludeParam>),
            Fetch(media_job::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Jobs(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("jobs");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        let mut nested_selections = <media_job::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<media_job::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: media_job::ManyArgs, nested_selections: Vec<media_job::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: media_job::ManyArgs, nested_selections: Vec<media_job::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(media_job::ManyArgs, Vec<media_job::SelectParam>),
            Include(media_job::ManyArgs, Vec<media_job::IncludeParam>),
            Fetch(media_job::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Jobs(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("jobs");
                match self {
                    Self::Select(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(args, selections) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch(args) => {
                        selection.set_arguments(args.to_graphql().0);
                        selection.nested_selections(<media_job::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(args: media_job::ManyArgs, nested_selections: Vec<media_job::SelectParam>) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(args: media_job::ManyArgs, nested_selections: Vec<media_job::IncludeParam>) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(id: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (id, _params)
    }
    pub fn create_unchecked(id: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (id, _params)
    }
    #[macro_export]
    macro_rules ! _select_media_file { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: media_file :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: media_file :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: media_file :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: media_file :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: media_file :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: media_file :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , path , metadata , last_used , revision , jobs } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: media_file :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: media_file :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: media_file :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: media_file :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_file :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_file :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "path" , "metadata" , "last_used" , "revision" , "jobs"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: media_file :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; path) => { Option < String > } ; (@ field_type ; metadata) => { Option < String > } ; (@ field_type ; last_used) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; revision) => { i64 } ; (@ field_type ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < jobs :: Data > } ; (@ field_type ; jobs) => { Vec < crate :: prisma :: media_job :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "MediaFile" , available fields are "id, path, metadata, last_used, revision, jobs")) } ; (@ field_module ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: media_job :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: media_file :: SelectParam > :: into ($ crate :: prisma :: media_file :: id :: Select) } ; (@ selection_field_to_selection_param ; path) => { Into :: < $ crate :: prisma :: media_file :: SelectParam > :: into ($ crate :: prisma :: media_file :: path :: Select) } ; (@ selection_field_to_selection_param ; metadata) => { Into :: < $ crate :: prisma :: media_file :: SelectParam > :: into ($ crate :: prisma :: media_file :: metadata :: Select) } ; (@ selection_field_to_selection_param ; last_used) => { Into :: < $ crate :: prisma :: media_file :: SelectParam > :: into ($ crate :: prisma :: media_file :: last_used :: Select) } ; (@ selection_field_to_selection_param ; revision) => { Into :: < $ crate :: prisma :: media_file :: SelectParam > :: into ($ crate :: prisma :: media_file :: revision :: Select) } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: media_file :: SelectParam > :: into ($ crate :: prisma :: media_file :: jobs :: Select :: $ selection_mode ($ crate :: prisma :: media_job :: ManyArgs :: new ($ crate :: prisma :: media_job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: media_job :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: media_file :: SelectParam > :: into ($ crate :: prisma :: media_file :: jobs :: Select :: Fetch ($ crate :: prisma :: media_job :: ManyArgs :: new ($ crate :: prisma :: media_job :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: media_file :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; last_used) => { "last_used" } ; (@ field_serde_name ; revision) => { "revision" } ; (@ field_serde_name ; jobs) => { "jobs" } ; }
    pub use _select_media_file as select;
    pub enum SelectParam {
        Id(id::Select),
        Path(path::Select),
        Metadata(metadata::Select),
        LastUsed(last_used::Select),
        Revision(revision::Select),
        Jobs(jobs::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Path(data) => data.to_selection(),
                Self::Metadata(data) => data.to_selection(),
                Self::LastUsed(data) => data.to_selection(),
                Self::Revision(data) => data.to_selection(),
                Self::Jobs(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_media_file { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: media_file :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: media_file :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: media_file :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: media_file :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: media_file :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: media_file :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: media_file :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: media_file :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { jobs } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub path : Option < String > , pub metadata : Option < String > , pub last_used : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub revision : i64 , $ (pub $ field : $ crate :: prisma :: media_file :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (path) , stringify ! (metadata) , stringify ! (last_used) , stringify ! (revision)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; path) , & self . path) ? ; state . serialize_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; metadata) , & self . metadata) ? ; state . serialize_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; last_used) , & self . last_used) ? ; state . serialize_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; revision) , & self . revision) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , path , metadata , last_used , revision } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; path) , ", " , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; metadata) , ", " , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; last_used) , ", " , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; revision) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; path) => Ok (Field :: path) , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; metadata) => Ok (Field :: metadata) , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; last_used) => Ok (Field :: last_used) , $ crate :: prisma :: media_file :: include ! (@ field_serde_name ; revision) => Ok (Field :: revision) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut path = None ; let mut metadata = None ; let mut last_used = None ; let mut revision = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: path => { if path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; path))) ; } path = Some (map . next_value () ?) ; } Field :: metadata => { if metadata . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; metadata))) ; } metadata = Some (map . next_value () ?) ; } Field :: last_used => { if last_used . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; last_used))) ; } last_used = Some (map . next_value () ?) ; } Field :: revision => { if revision . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; revision))) ; } revision = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; id))) ? ; let path = path . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; path))) ? ; let metadata = metadata . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; metadata))) ? ; let last_used = last_used . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; last_used))) ? ; let revision = revision . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_file :: include ! (@ field_serde_name ; revision))) ? ; Ok (Data { id , path , metadata , last_used , revision , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "path" , "metadata" , "last_used" , "revision" , "jobs"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: media_file :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < jobs :: Data > } ; (@ field_type ; jobs) => { Vec < crate :: prisma :: media_job :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "MediaFile" , available relations are "jobs")) } ; (@ field_module ; jobs : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: media_job :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: media_file :: IncludeParam > :: into ($ crate :: prisma :: media_file :: jobs :: Include :: $ selection_mode ($ crate :: prisma :: media_job :: ManyArgs :: new ($ crate :: prisma :: media_job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: media_job :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; jobs $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: media_file :: IncludeParam > :: into ($ crate :: prisma :: media_file :: jobs :: Include :: Fetch ($ crate :: prisma :: media_job :: ManyArgs :: new ($ crate :: prisma :: media_job :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: media_file :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; last_used) => { "last_used" } ; (@ field_serde_name ; revision) => { "revision" } ; (@ field_serde_name ; jobs) => { "jobs" } ; }
    pub use _include_media_file as include;
    pub enum IncludeParam {
        Id(id::Include),
        Path(path::Include),
        Metadata(metadata::Include),
        LastUsed(last_used::Include),
        Revision(revision::Include),
        Jobs(jobs::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Path(data) => data.to_selection(),
                Self::Metadata(data) => data.to_selection(),
                Self::LastUsed(data) => data.to_selection(),
                Self::Revision(data) => data.to_selection(),
                Self::Jobs(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id:        String,
        #[serde(rename = "path")]
        pub path:      Option<String>,
        #[serde(rename = "metadata")]
        pub metadata:  Option<String>,
        #[serde(rename = "last_used")]
        pub last_used: Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
        #[serde(rename = "revision")]
        pub revision:  i64,
        #[serde(rename = "jobs")]
        pub jobs:      Option<Vec<super::media_job::Data>>,
    }
    impl Data {
        pub fn jobs(&self) -> Result<&Vec<super::media_job::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.jobs
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(jobs)))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Jobs(super::media_job::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Jobs(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections.extend(<super::media_job::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    let mut builder = ::prisma_client_rust::Selection::builder("jobs");
                    builder.nested_selections(nested_selections).set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetPath(Option<String>),
        SetMetadata(Option<String>),
        SetLastUsed(Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
        SetRevision(i64),
        IncrementRevision(i64),
        DecrementRevision(i64),
        MultiplyRevision(i64),
        DivideRevision(i64),
        ConnectJobs(Vec<super::media_job::UniqueWhereParam>),
        DisconnectJobs(Vec<super::media_job::UniqueWhereParam>),
        SetJobs(Vec<super::media_job::UniqueWhereParam>),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetPath (value) => ("path" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetMetadata (value) => ("metadata" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetLastUsed (value) => ("last_used" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetRevision (value) => ("revision" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value)) , SetParam :: IncrementRevision (value) => ("revision" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: DecrementRevision (value) => ("revision" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: MultiplyRevision (value) => ("revision" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: DivideRevision (value) => ("revision" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , SetParam :: ConnectJobs (where_params) => ("jobs" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: media_job :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: DisconnectJobs (where_params) => ("jobs" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: media_job :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , SetParam :: SetJobs (where_params) => ("jobs" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (Into :: < super :: media_job :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Path(::prisma_client_rust::Direction),
        Metadata(::prisma_client_rust::Direction),
        LastUsed(::prisma_client_rust::Direction),
        Revision(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Path(direction) => ("path".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Metadata(direction) => ("metadata".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::LastUsed(direction) => ("last_used".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Revision(direction) => ("revision".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        Id(_prisma::read_filters::StringFilter),
        PathEquals(Option<String>),
        Path(_prisma::read_filters::StringFilter),
        MetadataEquals(Option<String>),
        Metadata(_prisma::read_filters::StringFilter),
        LastUsedEquals(Option<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
        LastUsed(_prisma::read_filters::DateTimeFilter),
        RevisionEquals(i64),
        Revision(_prisma::read_filters::BigIntFilter),
        JobsSome(Vec<super::media_job::WhereParam>),
        JobsEvery(Vec<super::media_job::WhereParam>),
        JobsNone(Vec<super::media_job::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: PathEquals (value) => ("path" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: Path (value) => ("path" , value . into ()) , Self :: MetadataEquals (value) => ("metadata" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: Metadata (value) => ("metadata" , value . into ()) , Self :: LastUsedEquals (value) => ("last_used" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: LastUsed (value) => ("last_used" , value . into ()) , Self :: RevisionEquals (value) => ("revision" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))])) , Self :: Revision (value) => ("revision" , value . into ()) , Self :: JobsSome (where_params) => ("jobs" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: JobsEvery (where_params) => ("jobs" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: JobsNone (where_params) => ("jobs" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "MediaFile";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "path", "metadata", "last_used", "revision"].into_iter()
                                                               .map(|o| {
                                                                   let builder = ::prisma_client_rust::Selection::builder(o);
                                                                   builder.build()
                                                               })
                                                               .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, id: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            Create::new(self.client, _params)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(self, _where: UniqueWhereParam, (id, mut _params): (String, Vec<SetParam>), _update: Vec<SetParam>) -> Upsert<'a> {
            _params.push(id::set(id));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod media_job {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod media_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MediaIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MediaId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::MediaId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetMediaId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MediaId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("media_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MediaId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("media_id").build()
            }
        }
    }
    pub mod status {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::StatusEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Status(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStatus(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Status(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("status").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Status(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("status").build()
            }
        }
    }
    pub mod config {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ConfigEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Config(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Config(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetConfig(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Config(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Config(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("config").build()
            }
        }
    }
    pub mod kind {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::KindEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Kind(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetKind(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Kind(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kind").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Kind(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("kind").build()
            }
        }
    }
    pub mod in_progress {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::InProgressEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::InProgress(direction)
        }
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetInProgress(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::InProgress(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("in_progress").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::InProgress(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("in_progress").build()
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCreatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("created_at").build()
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAtEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
        }
        pub fn lt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
        }
        pub fn lte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
        }
        pub fn gt(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
        }
        pub fn gte(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
        }
        pub fn not(value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
        }
        pub struct Set(pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUpdatedAt(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UpdatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("updated_at").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UpdatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("updated_at").build()
            }
        }
    }
    pub mod media_file {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<media_file::WhereParam>) -> WhereParam {
            WhereParam::MediaFileIs(value)
        }
        pub fn is_not(value: Vec<media_file::WhereParam>) -> WhereParam {
            WhereParam::MediaFileIsNot(value)
        }
        pub struct Fetch(pub media_file::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<media_file::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::MediaFile(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(media_file::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: media_file::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub struct Connect(media_file::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectMediaFile(value.0)
            }
        }
        pub enum Include {
            Select(Vec<media_file::SelectParam>),
            Include(Vec<media_file::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MediaFile(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("MediaFile");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = <media_file::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(<media_file::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<media_file::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<media_file::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<media_file::SelectParam>),
            Include(Vec<media_file::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MediaFile(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("MediaFile");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch => {
                        selection.nested_selections(<media_file::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<media_file::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<media_file::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(id: String,
                  status: String,
                  config: String,
                  kind: String,
                  media_file: super::media_file::UniqueWhereParam,
                  _params: Vec<SetParam>)
                  -> (String, String, String, String, super::media_file::UniqueWhereParam, Vec<SetParam>) {
        (id, status, config, kind, media_file, _params)
    }
    pub fn create_unchecked(id: String,
                            media_id: String,
                            status: String,
                            config: String,
                            kind: String,
                            _params: Vec<SetParam>)
                            -> (String, String, String, String, String, Vec<SetParam>) {
        (id, media_id, status, config, kind, _params)
    }
    #[macro_export]
    macro_rules ! _select_media_job { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: media_job :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: media_job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: media_job :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: media_job :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: media_job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: media_job :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , media_id , status , config , kind , in_progress , created_at , updated_at , media_file } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: media_job :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: media_job :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: media_job :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: media_job :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "media_id" , "status" , "config" , "kind" , "in_progress" , "created_at" , "updated_at" , "MediaFile"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: media_job :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; media_id) => { String } ; (@ field_type ; status) => { String } ; (@ field_type ; config) => { String } ; (@ field_type ; kind) => { String } ; (@ field_type ; in_progress) => { bool } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; media_file : $ selection_mode : ident { $ ($ selections : tt) + }) => { media_file :: Data } ; (@ field_type ; media_file) => { crate :: prisma :: media_file :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "MediaJob" , available fields are "id, media_id, status, config, kind, in_progress, created_at, updated_at, media_file")) } ; (@ field_module ; media_file : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: media_file :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: id :: Select) } ; (@ selection_field_to_selection_param ; media_id) => { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: media_id :: Select) } ; (@ selection_field_to_selection_param ; status) => { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: status :: Select) } ; (@ selection_field_to_selection_param ; config) => { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: config :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: kind :: Select) } ; (@ selection_field_to_selection_param ; in_progress) => { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: in_progress :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: created_at :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; media_file $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: media_file :: Select :: $ selection_mode ($ crate :: prisma :: media_file :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; media_file $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: media_job :: SelectParam > :: into ($ crate :: prisma :: media_job :: media_file :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: media_job :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; media_id) => { "media_id" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; in_progress) => { "in_progress" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ field_serde_name ; media_file) => { "MediaFile" } ; }
    pub use _select_media_job as select;
    pub enum SelectParam {
        Id(id::Select),
        MediaId(media_id::Select),
        Status(status::Select),
        Config(config::Select),
        Kind(kind::Select),
        InProgress(in_progress::Select),
        CreatedAt(created_at::Select),
        UpdatedAt(updated_at::Select),
        MediaFile(media_file::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::MediaId(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::InProgress(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
                Self::MediaFile(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_media_job { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: media_job :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: media_job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: media_job :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: media_job :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: media_job :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: media_job :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: media_job :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: media_job :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { media_file } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub media_id : String , pub status : String , pub config : String , pub kind : String , pub in_progress : bool , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: media_job :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (media_id) , stringify ! (status) , stringify ! (config) , stringify ! (kind) , stringify ! (in_progress) , stringify ! (created_at) , stringify ! (updated_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; media_id) , & self . media_id) ? ; state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; status) , & self . status) ? ; state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; config) , & self . config) ? ; state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; kind) , & self . kind) ? ; state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; in_progress) , & self . in_progress) ? ; state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . serialize_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; updated_at) , & self . updated_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , media_id , status , config , kind , in_progress , created_at , updated_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; media_id) , ", " , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; status) , ", " , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; config) , ", " , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; kind) , ", " , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; in_progress) , ", " , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; created_at) , ", " , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; updated_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; media_id) => Ok (Field :: media_id) , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; status) => Ok (Field :: status) , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; config) => Ok (Field :: config) , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; kind) => Ok (Field :: kind) , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; in_progress) => Ok (Field :: in_progress) , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , $ crate :: prisma :: media_job :: include ! (@ field_serde_name ; updated_at) => Ok (Field :: updated_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut media_id = None ; let mut status = None ; let mut config = None ; let mut kind = None ; let mut in_progress = None ; let mut created_at = None ; let mut updated_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: media_id => { if media_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; media_id))) ; } media_id = Some (map . next_value () ?) ; } Field :: status => { if status . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; status))) ; } status = Some (map . next_value () ?) ; } Field :: config => { if config . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; config))) ; } config = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; kind))) ; } kind = Some (map . next_value () ?) ; } Field :: in_progress => { if in_progress . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; in_progress))) ; } in_progress = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; updated_at))) ; } updated_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; id))) ? ; let media_id = media_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; media_id))) ? ; let status = status . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; status))) ? ; let config = config . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; config))) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; kind))) ? ; let in_progress = in_progress . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; in_progress))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; created_at))) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: media_job :: include ! (@ field_serde_name ; updated_at))) ? ; Ok (Data { id , media_id , status , config , kind , in_progress , created_at , updated_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "media_id" , "status" , "config" , "kind" , "in_progress" , "created_at" , "updated_at" , "MediaFile"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: media_job :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; media_file : $ selection_mode : ident { $ ($ selections : tt) + }) => { media_file :: Data } ; (@ field_type ; media_file) => { crate :: prisma :: media_file :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "MediaJob" , available relations are "media_file")) } ; (@ field_module ; media_file : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: media_file :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; media_file $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: media_job :: IncludeParam > :: into ($ crate :: prisma :: media_job :: media_file :: Include :: $ selection_mode ($ crate :: prisma :: media_file :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; media_file $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: media_job :: IncludeParam > :: into ($ crate :: prisma :: media_job :: media_file :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: media_job :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; media_id) => { "media_id" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; config) => { "config" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; in_progress) => { "in_progress" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ field_serde_name ; media_file) => { "MediaFile" } ; }
    pub use _include_media_job as include;
    pub enum IncludeParam {
        Id(id::Include),
        MediaId(media_id::Include),
        Status(status::Include),
        Config(config::Include),
        Kind(kind::Include),
        InProgress(in_progress::Include),
        CreatedAt(created_at::Include),
        UpdatedAt(updated_at::Include),
        MediaFile(media_file::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::MediaId(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
                Self::Config(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::InProgress(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
                Self::MediaFile(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id:          String,
        #[serde(rename = "media_id")]
        pub media_id:    String,
        #[serde(rename = "status")]
        pub status:      String,
        #[serde(rename = "config")]
        pub config:      String,
        #[serde(rename = "kind")]
        pub kind:        String,
        #[serde(rename = "in_progress")]
        pub in_progress: bool,
        #[serde(rename = "created_at")]
        pub created_at:  ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "updated_at")]
        pub updated_at:  ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "MediaFile")]
        pub media_file:  Option<Box<super::media_file::Data>>,
    }
    impl Data {
        pub fn media_file(&self) -> Result<&super::media_file::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.media_file
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(media_file)))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        MediaFile(super::media_file::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::MediaFile(args) => {
                    let mut selections = <super::media_file::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                    selections.extend(args.with_params.into_iter().map(Into::<::prisma_client_rust::Selection>::into));
                    let mut builder = ::prisma_client_rust::Selection::builder("MediaFile");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetMediaId(String),
        SetStatus(String),
        SetConfig(String),
        SetKind(String),
        SetInProgress(bool),
        SetCreatedAt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        SetUpdatedAt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        ConnectMediaFile(super::media_file::UniqueWhereParam),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetMediaId (value) => ("media_id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetStatus (value) => ("status" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetConfig (value) => ("config" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetKind (value) => ("kind" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetInProgress (value) => ("in_progress" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value)) , SetParam :: SetCreatedAt (value) => ("created_at" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value)) , SetParam :: SetUpdatedAt (value) => ("updated_at" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value)) , SetParam :: ConnectMediaFile (where_param) => ("MediaFile" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: media_file :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        MediaId(::prisma_client_rust::Direction),
        Status(::prisma_client_rust::Direction),
        Config(::prisma_client_rust::Direction),
        Kind(::prisma_client_rust::Direction),
        InProgress(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        UpdatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::MediaId(direction) => ("media_id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Status(direction) => ("status".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Config(direction) => ("config".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Kind(direction) => ("kind".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::InProgress(direction) => {
                    ("in_progress".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string()))
                }
                Self::CreatedAt(direction) => ("created_at".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::UpdatedAt(direction) => ("updated_at".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        Id(_prisma::read_filters::StringFilter),
        MediaIdEquals(String),
        MediaId(_prisma::read_filters::StringFilter),
        StatusEquals(String),
        Status(_prisma::read_filters::StringFilter),
        ConfigEquals(String),
        Config(_prisma::read_filters::StringFilter),
        KindEquals(String),
        Kind(_prisma::read_filters::StringFilter),
        InProgressEquals(bool),
        CreatedAtEquals(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        UpdatedAtEquals(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        UpdatedAt(_prisma::read_filters::DateTimeFilter),
        MediaFileIs(Vec<super::media_file::WhereParam>),
        MediaFileIsNot(Vec<super::media_file::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: MediaIdEquals (value) => ("media_id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: MediaId (value) => ("media_id" , value . into ()) , Self :: StatusEquals (value) => ("status" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Status (value) => ("status" , value . into ()) , Self :: ConfigEquals (value) => ("config" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Config (value) => ("config" , value . into ()) , Self :: KindEquals (value) => ("kind" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Kind (value) => ("kind" , value . into ()) , Self :: InProgressEquals (value) => ("in_progress" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (value))])) , Self :: CreatedAtEquals (value) => ("created_at" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))])) , Self :: CreatedAt (value) => ("created_at" , value . into ()) , Self :: UpdatedAtEquals (value) => ("updated_at" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))])) , Self :: UpdatedAt (value) => ("updated_at" , value . into ()) , Self :: MediaFileIs (where_params) => ("MediaFile" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: MediaFileIsNot (where_params) => ("MediaFile" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "MediaJob";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id",
             "media_id",
             "status",
             "config",
             "kind",
             "in_progress",
             "created_at",
             "updated_at"].into_iter()
                          .map(|o| {
                              let builder = ::prisma_client_rust::Selection::builder(o);
                              builder.build()
                          })
                          .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self,
                      id: String,
                      status: String,
                      config: String,
                      kind: String,
                      media_file: super::media_file::UniqueWhereParam,
                      mut _params: Vec<SetParam>)
                      -> Create<'a> {
            _params.push(id::set(id));
            _params.push(status::set(status));
            _params.push(config::set(config));
            _params.push(kind::set(kind));
            _params.push(media_file::connect(media_file));
            Create::new(self.client, _params)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(self,
                      _where: UniqueWhereParam,
                      (id, status, config, kind, media_file, mut _params): (String,
                       String,
                       String,
                       String,
                       super::media_file::UniqueWhereParam,
                       Vec<SetParam>),
                      _update: Vec<SetParam>)
                      -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(status::set(status));
            _params.push(config::set(config));
            _params.push(kind::set(kind));
            _params.push(media_file::connect(media_file));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod task {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod engine_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::EngineIdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::EngineId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::EngineId(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetEngineId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::EngineId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("engine_id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::EngineId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("engine_id").build()
            }
        }
    }
    pub mod spec {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SpecEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Spec(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Spec(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSpec(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Spec(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("spec").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Spec(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("spec").build()
            }
        }
    }
    pub mod engine {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<engine::WhereParam>) -> WhereParam {
            WhereParam::EngineIs(value)
        }
        pub fn is_not(value: Vec<engine::WhereParam>) -> WhereParam {
            WhereParam::EngineIsNot(value)
        }
        pub struct Fetch(pub engine::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<engine::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(fetch: Fetch) -> Self {
                WithParam::Engine(fetch.0)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(engine::UniqueArgs::new())
        }
        pub fn connect<T: From<Connect>>(value: engine::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectEngine
        }
        pub struct Connect(engine::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(value: Connect) -> Self {
                Self::ConnectEngine(value.0)
            }
        }
        pub enum Include {
            Select(Vec<engine::SelectParam>),
            Include(Vec<engine::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Engine(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("engine");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = <engine::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        selection.nested_selections(nested_selections);
                    }
                    Self::Fetch => {
                        selection.nested_selections(<engine::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<engine::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<engine::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<engine::SelectParam>),
            Include(Vec<engine::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Engine(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let mut selection = ::prisma_client_rust::Selection::builder("engine");
                match self {
                    Self::Select(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Include(selections) => {
                        selection.nested_selections(selections.into_iter().map(|s| s.to_selection()).collect());
                    }
                    Self::Fetch => {
                        selection.nested_selections(<engine::Actions as ::prisma_client_rust::ModelActions>::scalar_selections());
                    }
                }
                selection.build()
            }
            pub fn select(nested_selections: Vec<engine::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<engine::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(id: String, spec: String, _params: Vec<SetParam>) -> (String, String, Vec<SetParam>) {
        (id, spec, _params)
    }
    pub fn create_unchecked(id: String, spec: String, _params: Vec<SetParam>) -> (String, String, Vec<SetParam>) {
        (id, spec, _params)
    }
    #[macro_export]
    macro_rules ! _select_task { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: task :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: task :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: task :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: task :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: task :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: task :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , engine_id , spec , engine } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: task :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: task :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: task :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: task :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: task :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: task :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "engine_id" , "spec" , "engine"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: task :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; engine_id) => { Option < String > } ; (@ field_type ; spec) => { String } ; (@ field_type ; engine : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < engine :: Data > } ; (@ field_type ; engine) => { Option < crate :: prisma :: engine :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "Task" , available fields are "id, engine_id, spec, engine")) } ; (@ field_module ; engine : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: engine :: select ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: task :: SelectParam > :: into ($ crate :: prisma :: task :: id :: Select) } ; (@ selection_field_to_selection_param ; engine_id) => { Into :: < $ crate :: prisma :: task :: SelectParam > :: into ($ crate :: prisma :: task :: engine_id :: Select) } ; (@ selection_field_to_selection_param ; spec) => { Into :: < $ crate :: prisma :: task :: SelectParam > :: into ($ crate :: prisma :: task :: spec :: Select) } ; (@ selection_field_to_selection_param ; engine $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: task :: SelectParam > :: into ($ crate :: prisma :: task :: engine :: Select :: $ selection_mode ($ crate :: prisma :: engine :: select ! (@ selections_to_select_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; engine $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: task :: SelectParam > :: into ($ crate :: prisma :: task :: engine :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: task :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; engine_id) => { "engine_id" } ; (@ field_serde_name ; spec) => { "spec" } ; (@ field_serde_name ; engine) => { "engine" } ; }
    pub use _select_task as select;
    pub enum SelectParam {
        Id(id::Select),
        EngineId(engine_id::Select),
        Spec(spec::Select),
        Engine(engine::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::EngineId(data) => data.to_selection(),
                Self::Spec(data) => data.to_selection(),
                Self::Engine(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_task { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: task :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: task :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: task :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: task :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: task :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: task :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: task :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: task :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { engine } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub engine_id : Option < String > , pub spec : String , $ (pub $ field : $ crate :: prisma :: task :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (engine_id) , stringify ! (spec)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; engine_id) , & self . engine_id) ? ; state . serialize_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; spec) , & self . spec) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , engine_id , spec } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: task :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: task :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: task :: include ! (@ field_serde_name ; engine_id) , ", " , $ crate :: prisma :: task :: include ! (@ field_serde_name ; spec) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: task :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: task :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: task :: include ! (@ field_serde_name ; engine_id) => Ok (Field :: engine_id) , $ crate :: prisma :: task :: include ! (@ field_serde_name ; spec) => Ok (Field :: spec) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut engine_id = None ; let mut spec = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: engine_id => { if engine_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; engine_id))) ; } engine_id = Some (map . next_value () ?) ; } Field :: spec => { if spec . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; spec))) ; } spec = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; id))) ? ; let engine_id = engine_id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; engine_id))) ? ; let spec = spec . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: task :: include ! (@ field_serde_name ; spec))) ? ; Ok (Data { id , engine_id , spec , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "engine_id" , "spec" , "engine"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: task :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; engine : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < engine :: Data > } ; (@ field_type ; engine) => { Option < crate :: prisma :: engine :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Task" , available relations are "engine")) } ; (@ field_module ; engine : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: engine :: include ! (@ definitions ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; engine $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: task :: IncludeParam > :: into ($ crate :: prisma :: task :: engine :: Include :: $ selection_mode ($ crate :: prisma :: engine :: include ! (@ selections_to_include_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; engine $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: task :: IncludeParam > :: into ($ crate :: prisma :: task :: engine :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: task :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; engine_id) => { "engine_id" } ; (@ field_serde_name ; spec) => { "spec" } ; (@ field_serde_name ; engine) => { "engine" } ; }
    pub use _include_task as include;
    pub enum IncludeParam {
        Id(id::Include),
        EngineId(engine_id::Include),
        Spec(spec::Include),
        Engine(engine::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::EngineId(data) => data.to_selection(),
                Self::Spec(data) => data.to_selection(),
                Self::Engine(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id:        String,
        #[serde(rename = "engine_id")]
        pub engine_id: Option<String>,
        #[serde(rename = "spec")]
        pub spec:      String,
        #[serde(rename = "engine",
                default,
                skip_serializing_if = "Option::is_none",
                with = "prisma_client_rust::serde::double_option")]
        pub engine:    Option<Option<Box<super::engine::Data>>>,
    }
    impl Data {
        pub fn engine(&self) -> Result<Option<&super::engine::Data>, ::prisma_client_rust::RelationNotFetchedError> {
            self.engine
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(stringify!(engine)))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Engine(super::engine::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Engine(args) => {
                    let mut selections = <super::engine::Actions as ::prisma_client_rust::ModelActions>::scalar_selections();
                    selections.extend(args.with_params.into_iter().map(Into::<::prisma_client_rust::Selection>::into));
                    let mut builder = ::prisma_client_rust::Selection::builder("engine");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetEngineId(Option<String>),
        SetSpec(String),
        ConnectEngine(super::engine::UniqueWhereParam),
        DisconnectEngine,
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self { SetParam :: SetId (value) => ("id" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetEngineId (value) => ("engine_id" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null)) , SetParam :: SetSpec (value) => ("spec" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectEngine (where_param) => ("engine" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: engine :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: DisconnectEngine => ("engine" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        EngineId(::prisma_client_rust::Direction),
        Spec(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::EngineId(direction) => ("engine_id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Spec(direction) => ("spec".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        Id(_prisma::read_filters::StringFilter),
        EngineIdEquals(Option<String>),
        EngineId(_prisma::read_filters::StringFilter),
        SpecEquals(String),
        Spec(_prisma::read_filters::StringFilter),
        EngineIs(Vec<super::engine::WhereParam>),
        EngineIsNot(Vec<super::engine::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: EngineIdEquals (value) => ("engine_id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or (:: prisma_client_rust :: PrismaValue :: Null))])) , Self :: EngineId (value) => ("engine_id" , value . into ()) , Self :: SpecEquals (value) => ("spec" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Spec (value) => ("spec" , value . into ()) , Self :: EngineIs (where_params) => ("engine" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: EngineIsNot (where_params) => ("engine" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "Task";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "engine_id", "spec"].into_iter()
                                       .map(|o| {
                                           let builder = ::prisma_client_rust::Selection::builder(o);
                                           builder.build()
                                       })
                                       .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, id: String, spec: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(spec::set(spec));
            Create::new(self.client, _params)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(self,
                      _where: UniqueWhereParam,
                      (id, spec, mut _params): (String, String, Vec<SetParam>),
                      _update: Vec<SetParam>)
                      -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(spec::set(spec));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod sys_prop {
    use super::_prisma::*;
    use super::*;
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Id(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("id").build()
            }
        }
    }
    pub mod value {
        use super::super::*;
        use super::_prisma::*;
        use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::ValueEquals(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Value(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::InVec(value))
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::NotInVec(value))
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::Lt(value))
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::Lte(value))
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::Gt(value))
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::Gte(value))
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::Contains(value))
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::StartsWith(value))
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::EndsWith(value))
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::Not(value))
        }
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetValue(value.0)
            }
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Value(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("value").build()
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Value(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::Selection::builder("value").build()
            }
        }
    }
    pub fn create(id: String, value: String, _params: Vec<SetParam>) -> (String, String, Vec<SetParam>) {
        (id, value, _params)
    }
    pub fn create_unchecked(id: String, value: String, _params: Vec<SetParam>) -> (String, String, Vec<SetParam>) {
        (id, value, _params)
    }
    #[macro_export]
    macro_rules ! _select_sys_prop { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: sys_prop :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: sys_prop :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: sys_prop :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: sys_prop :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: sys_prop :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: sys_prop :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , value } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: sys_prop :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: sys_prop :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: sys_prop :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: sys_prop :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: sys_prop :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: sys_prop :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "value"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: sys_prop :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; value) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "SysProp" , available fields are "id, value")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: sys_prop :: SelectParam > :: into ($ crate :: prisma :: sys_prop :: id :: Select) } ; (@ selection_field_to_selection_param ; value) => { Into :: < $ crate :: prisma :: sys_prop :: SelectParam > :: into ($ crate :: prisma :: sys_prop :: value :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: sys_prop :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; value) => { "value" } ; }
    pub use _select_sys_prop as select;
    pub enum SelectParam {
        Id(id::Select),
        Value(value::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Value(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_sys_prop { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: sys_prop :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: sys_prop :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = < $ crate :: prisma :: sys_prop :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: sys_prop :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: sys_prop :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: sys_prop :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = < $ crate :: prisma :: sys_prop :: Actions as :: prisma_client_rust :: ModelActions > :: scalar_selections () ; selections . extend ($ crate :: prisma :: sys_prop :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub value : String , $ (pub $ field : $ crate :: prisma :: sys_prop :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (value)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; value) , & self . value) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , value } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; value) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; value) => Ok (Field :: value) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut value = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: value => { if value . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; value))) ; } value = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; id))) ? ; let value = value . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: sys_prop :: include ! (@ field_serde_name ; value))) ? ; Ok (Data { id , value , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "value"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: sys_prop :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SysProp" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: sys_prop :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; value) => { "value" } ; }
    pub use _include_sys_prop as include;
    pub enum IncludeParam {
        Id(id::Include),
        Value(value::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Value(data) => data.to_selection(),
            }
        }
    }
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id:    String,
        #[serde(rename = "value")]
        pub value: String,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetValue(String),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(value)),
                SetParam::SetValue(value) => ("value".to_string(), ::prisma_client_rust::PrismaValue::String(value)),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Value(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => ("id".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
                Self::Value(direction) => ("value".to_string(), ::prisma_client_rust::PrismaValue::String(direction.to_string())),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        Id(_prisma::read_filters::StringFilter),
        ValueEquals(String),
        Value(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Id (value) => ("id" , value . into ()) , Self :: ValueEquals (value) => ("value" , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))])) , Self :: Value (value) => ("value" , value . into ()) } ;
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Actions<'static>>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Actions<'static>>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Actions<'static>>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Actions<'static>>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Actions<'static>>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Actions<'static>>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Actions<'static>>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Actions<'static>>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Actions<'static>>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Actions<'static>>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Actions<'static>>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Actions<'static>>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Actions<'static>>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl ::prisma_client_rust::ModelActions for Actions<'_> {
        type Data = Data;
        type Where = WhereParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = "SysProp";
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            ["id", "value"].into_iter()
                           .map(|o| {
                               let builder = ::prisma_client_rust::Selection::builder(o);
                               builder.build()
                           })
                           .collect()
        }
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, id: String, value: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.push(id::set(id));
            _params.push(value::set(value));
            Create::new(self.client, _params)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(self,
                      _where: UniqueWhereParam,
                      (id, value, mut _params): (String, String, Vec<SetParam>),
                      _update: Vec<SetParam>)
                      -> Upsert<'a> {
            _params.push(id::set(id));
            _params.push(value::set(value));
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url:             Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        pub fn new() -> Self {
            Self { url:             None,
                   action_notifier: ::prisma_client_rust::ActionNotifier::new(), }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let config = ::prisma_client_rust::datamodel::parse_configuration(super::DATAMODEL_STR)?.subject;
            let source = config.datasources
                               .first()
                               .expect("Please supply a datasource in your schema.prisma file");
            let url = match self.url {
                Some(url) => url,
                None => {
                    let url = if let Some(url) = source.load_shadow_database_url()? {
                        url
                    } else {
                        source.load_url(|key| std::env::var(key).ok())?
                    };
                    match url.starts_with("file:") {
                        true => {
                            let path = url.split(":").nth(1).unwrap();
                            if std::path::Path::new("./prisma/schema.prisma").exists() {
                                format!("file:./prisma/{}", path)
                            } else {
                                url
                            }
                        }
                        _ => url,
                    }
                }
            };
            let (db_name, executor) = ::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
            let internal_model = ::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(super::DATAMODEL_STR).build(db_name);
            let query_schema = std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(internal_model,
                                                                                                         true,
                                                                                                         source.capabilities(),
                                                                                                         vec![],
                                                                                                         source.referential_integrity()));
            executor.primary_connector().get_connection().await?;
            Ok(PrismaClient(::prisma_client_rust::PrismaClientInternals { executor,
                                                                          query_schema,
                                                                          url,
                                                                          action_notifier:
                                                                              self.action_notifier }))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: serde::de::DeserializeOwned>(&self, query: ::prisma_client_rust::Raw) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(&self, query: ::prisma_client_rust::Raw) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(&self,
                                                                                     queries: T)
                                                                                     -> ::prisma_client_rust::Result<T::ReturnType>
        {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub async fn _migrate_deploy(&self) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
            let res = ::prisma_client_rust::migrations::migrate_deploy(super::DATAMODEL_STR, super::MIGRATIONS_DIR, &self.0.url).await;
            ::prisma_client_rust::tokio::time::sleep(core::time::Duration::from_millis(1)).await;
            res
        }
        pub async fn _migrate_resolve(&self, migration: &str) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
            ::prisma_client_rust::migrations::migrate_resolve(migration, super::DATAMODEL_STR, super::MIGRATIONS_DIR, &self.0.url).await
        }
        pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
            ::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.0.url)
        }
        pub fn model(&self) -> super::model::Actions {
            super::model::Actions { client: &self.0 }
        }
        pub fn fixed_instance(&self) -> super::fixed_instance::Actions {
            super::fixed_instance::Actions { client: &self.0 }
        }
        pub fn fixed_instance_driver(&self) -> super::fixed_instance_driver::Actions {
            super::fixed_instance_driver::Actions { client: &self.0 }
        }
        pub fn engine(&self) -> super::engine::Actions {
            super::engine::Actions { client: &self.0 }
        }
        pub fn media_file(&self) -> super::media_file::Actions {
            super::media_file::Actions { client: &self.0 }
        }
        pub fn media_job(&self) -> super::media_job::Actions {
            super::media_job::Actions { client: &self.0 }
        }
        pub fn task(&self) -> super::task::Actions {
            super::task::Actions { client: &self.0 }
        }
        pub fn sys_prop(&self) -> super::sys_prop::Actions {
            super::sys_prop::Actions { client: &self.0 }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum EngineScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "last_seen")]
        LastSeen,
        #[serde(rename = "config")]
        Config,
    }
    impl ToString for EngineScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Url => "url".to_string(),
                Self::LastSeen => "last_seen".to_string(),
                Self::Config => "config".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum FixedInstanceDriverScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "last_seen")]
        LastSeen,
        #[serde(rename = "config")]
        Config,
    }
    impl ToString for FixedInstanceDriverScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Url => "url".to_string(),
                Self::LastSeen => "last_seen".to_string(),
                Self::Config => "config".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum FixedInstanceScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "model_id")]
        ModelId,
        #[serde(rename = "driver_id")]
        DriverId,
        #[serde(rename = "engine_id")]
        EngineId,
        #[serde(rename = "config")]
        Config,
    }
    impl ToString for FixedInstanceScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::ModelId => "model_id".to_string(),
                Self::DriverId => "driver_id".to_string(),
                Self::EngineId => "engine_id".to_string(),
                Self::Config => "config".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum MediaFileScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "path")]
        Path,
        #[serde(rename = "metadata")]
        Metadata,
        #[serde(rename = "last_used")]
        LastUsed,
        #[serde(rename = "revision")]
        Revision,
    }
    impl ToString for MediaFileScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Path => "path".to_string(),
                Self::Metadata => "metadata".to_string(),
                Self::LastUsed => "last_used".to_string(),
                Self::Revision => "revision".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum MediaJobScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "media_id")]
        MediaId,
        #[serde(rename = "status")]
        Status,
        #[serde(rename = "config")]
        Config,
        #[serde(rename = "kind")]
        Kind,
        #[serde(rename = "in_progress")]
        InProgress,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "updated_at")]
        UpdatedAt,
    }
    impl ToString for MediaJobScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::MediaId => "media_id".to_string(),
                Self::Status => "status".to_string(),
                Self::Config => "config".to_string(),
                Self::Kind => "kind".to_string(),
                Self::InProgress => "in_progress".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::UpdatedAt => "updated_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum ModelScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "spec")]
        Spec,
    }
    impl ToString for ModelScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Spec => "spec".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum SysPropScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "value")]
        Value,
    }
    impl ToString for SysPropScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Value => "value".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TaskScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "engine_id")]
        EngineId,
        #[serde(rename = "spec")]
        Spec,
    }
    impl ToString for TaskScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::EngineId => "engine_id".to_string(),
                Self::Spec => "spec".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    pub mod read_filters {
        use super::*;
        #[derive(Clone)]
        pub enum StringFilter {
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self { Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: String (v)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            InVec(Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
            NotInVec(Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self { Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: DateTime (v)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: DateTime (v)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) }
            }
        }
        #[derive(Clone)]
        pub enum BigIntFilter {
            InVec(Vec<i64>),
            NotInVec(Vec<i64>),
            Lt(i64),
            Lte(i64),
            Gt(i64),
            Gte(i64),
            Not(i64),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self { Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: BigInt (v)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| v | :: prisma_client_rust :: PrismaValue :: BigInt (v)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: BigInt (value))]) }
            }
        }
    }
}
pub use _prisma::PrismaClient;
